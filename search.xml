<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[简单的iptables配置过程]]></title>
    <url>%2F2018%2F10%2F19%2F%E7%AE%80%E5%8D%95%E7%9A%84iptables%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[简单的记一下iptables的配置过程，以后用到了就不用再google了总的来说分为四步，清楚规则，预设规则，添加自定义规则，保存规则 iptables配置过程1.清除规则:清楚旧的规则iptables -F 清除预设表filter中的所有规则链的规则iptables -X 清除预设表filter中使用者自定链中的规则2.设定预设规则默认情况下对各种包的处理方式iptables -p INPUT DROPiptables -p OUTPUT ACCEPTiptables -p FORWARD DROP3.添加用户自定义规则对于特定端口协议的包的规则进行设置iptables -A INPUT -p tcp —dport 22 -j ACCEPT-A:表示添加规则到INPUT(OUTPUT,FORWARD)链-p:表示tcp(udp)协议—dport(—sport):目的端口号(源端口号)-j():添加规则为接受4.保存规则不保存的话重启后就没有了service iptables save 参考资料1.http://www.cnblogs.com/JemBai/archive/2009/03/19/1416364.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[socket网络编程]]></title>
    <url>%2F2018%2F10%2F18%2Fwindows%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[socket网络编程int inet_aton(const char *cp, struct in_addr *inp);转换网络主机地址为二进制数值并存储与第二个参数中函数返回0表示主机地址无效，非0表示主机地址有效转化完后需要调用htons或htonl函数才能将主机字节序转换为网络字节序用于网络传输 char *inet_ntoa(struct in_addr in);转换网络字节序为标准的ASCII以点分开的地址，函数返回字符串指针该字符串空间为静态分配，第二次调用时会覆盖第一次的内容 in_addr_t inet_addr(const char *cp);转换网络主机地址为网络字节序二进制值参数无效，返回-1(INADDR_NONE)注意：转换255.255.255.255时也返回-1 int inet_pton(int af, const char *src, void *dst);转换字符串到网络地址，af是地址簇，src是来源地址， dst接收转换后的数据。 const char *inet_ntop(int af, const void *src, char *dst, socklen_t cnt);转换网络字节序二进制值到ASCII类型的地址，参数的作用和inet_pton相同，socklen_t cnt指所指向缓存区dst的大小，避免溢出，如果缓存区太小无法存储地址的值，则返回一个空指针，并将errno置为ENOSPC。 int select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval*timeout);int maxfdp 指集合中所有文件描述符的范围，即所有文件描述符的最大值加1，不能错！在Windows中这个参数的值无所谓，可以设置不正确。struct fd_set 可以理解为一个集合，这个集合中存放的是文件描述符(filedescriptor)，即文件句柄。监视这些文件描述符的读变化 int setsockopt(SOCKET s,int level,int optname,const char* optval,int optlen);s(套接字): 指向一个打开的套接口描述字level:(级别)： 指定选项代码的类型。 SOL_SOCKET: 基本套接口 IPPROTO_IP: IPv4套接口 IPPROTO_IPV6: IPv6套接口 IPPROTO_TCP: TCP套接口optname(选项名)： 选项名称optval(选项值): 是一个指向变量的指针 类型：整形，套接口结构， 其他结构类型:linger{}, timeval{ }optlen(选项长度) ：optval 的大小 int PASCAL FAR recvfrom( SOCKET s, char FAR* buf, int len, int flags,struct sockaddr FAR* from, int FAR* fromlen);s：标识一个已连接套接口的描述字。buf：接收数据缓冲区。len：缓冲区长度。flags：调用操作方式。from：（可选）指针，指向装有源地址的缓冲区。fromlen：（可选）指针，指向from缓冲区长度值。 参考资料1.https://blog.csdn.net/zyy617532750/article/details/585957002.https://www.cnblogs.com/zhoudingcocng/p/6209961.html]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[形式语言与自动机基础知识]]></title>
    <url>%2F2018%2F09%2F22%2F%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[形式语言与自动机这门课需要有离散数学的基础，但本科通信工程里没有学过这门课，总结一些这门课中需要的基础知识 1.集合及其运算1.1子集和真子集$A$是$B$的子集：$A\subseteq B$或$B\supseteq A$$A$是$B$的真子集：$A\subset B$或$B\supset A$$x$是$A$的一个元素：$x\in A$$x$不是$A$的一个元素：$x\notin A$ 1.2集合的交并差补$A$和$B$的并集：$A\cup B=\{x|x\in A或x\in B\}$$A$和$B$的交集：$A\cap B=\{x|x\in A且x\in B\}$$A$和$B$的差集：$A - B=\{x|x\in A且x\notin B\}$若$B\subseteq A$我们也称$A - B$为$B$的（关于$A$）补,记作：$\overline B(A)$ 1.3集合的并的推广设$I$是某些标号的集合我们将$\displaystyle \bigcup_{i\in I}A_i=\{x|存在i\in I,使得x\in A_i\}$ 1.4A的幂集$A$的所有子集的集合，记作$2^A=\{B|B\subseteq A\}$ 1.5笛卡尔乘积$A\times B=\{(a,b)|a\in A且b\in B\}$ 1.6集合之间的关系由$A$到$B$的关系是$A\times B$的任何子集。若$A=B$，则称为$A$上的关系。若$R$为$A$到$B$的关系，当$(a,b)$在$R$内时，可写成$aRb$ 1.7集合关系的性质设$R$是集合$A$上的关系，则有（1）若对$A$中的任一元素$a$，都有$aRa$，则称$R$是自反的；（2）若对$A$中的任何元素$a,b$，从$aRb$能够推到出$bRa$，则称$R$是对称的；（3）若$a,b,c$是$A$中的元素，从$aRb$和$bRc$能够推出$aRc$，则称$R$是传递的；若关系$R$同时是自反的，对称的和传递的，则称之为等价关系。2018-09-22 15:28:12 参考资料1.《形式语言与自动机》陈有祺编著]]></content>
      <categories>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梯度旋度和散度]]></title>
    <url>%2F2018%2F09%2F08%2F%E6%A2%AF%E5%BA%A6%E6%97%8B%E5%BA%A6%E5%92%8C%E6%95%A3%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[有关梯度旋度和散度的定义和计算只做记录,不解释 1.定义1.1梯度设函数$u=f(x,y,z)$在空间区域$G$内具有一阶连续偏导数,其中点$P(x,y,z) \in G$向量 \left\{ \frac {\partial f}{\partial x}, \frac {\partial f}{\partial y}, \frac {\partial f}{\partial z} \right\}= \frac {\partial f}{\partial x}\vec i+ \frac {\partial f}{\partial y}\vec j+ \frac {\partial f}{\partial z}\vec k为函数$u=f(x,y,z)$在点$P(x,y,z)$的梯度记为$grad\;f(x,y,z)$或$\nabla f(x,y,z)$(注:$\nabla = \frac {\partial}{\partial x}\vec i+\frac {\partial}{\partial y}\vec j+\frac {\partial}{\partial z}\vec k$称为三维的向量微分算子) 1.2旋度在三维空间$G$中有三维直角坐标系$O_{xyz}$,设向量场: \vec v=v_x\vec i+v_y\vec j+v_z\vec k其中$v_x,v_y,v_z$具有一阶连续偏导数,点$P(x,y,z) \in G$向量 \begin{vmatrix} \vec i & \vec j & \vec k \\ \frac {\partial}{\partial x} & \frac {\partial}{\partial y} & \frac {\partial}{\partial z} \\ v_x & v_y & v_z \\ \end{vmatrix} = (\frac {\partial v_z}{\partial y} - \frac {\partial v_y}{\partial z})\vec i+ (\frac {\partial v_x}{\partial z} - \frac {\partial v_z}{\partial x})\vec j+ (\frac {\partial v_y}{\partial x} - \frac {\partial v_x}{\partial y})\vec k为向量场$\vec v$在点$P(x,y,z)$的旋度记为$curl\;v$或者$\nabla \times v$ 1.3散度在三维空间$G$中有三维直角坐标系$O_{xyz}$,设向量场: \vec v=v_x\vec i+v_y\vec j+v_z\vec k其中$v_x,v_y,v_z$具有一阶连续偏导数,点$P(x,y,z) \in G$标量 \frac {\partial v_x}{\partial x}+ \frac {\partial v_y}{\partial y}+ \frac {\partial v_z}{\partial z}为向量场$\vec v$在点$P(x,y,z)$的散度记为$div\;v$或者$\nabla \cdot v$2018-09-08 15:26:31]]></content>
      <categories>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中遇到的错误1]]></title>
    <url>%2F2018%2F09%2F07%2Fpython%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[使用python过程中遇到的错误 1.使用libsvm for python时出错1234567891011121314151617Traceback (most recent call last): File &quot;C:\Python36\lib\libsvm\python\svm.py&quot;, line 28, in &lt;module&gt; libsvm = CDLL(path.join(dirname, r&apos;..\windows\libsvm.dll&apos;)) File &quot;C:\Python36\lib\ctypes\__init__.py&quot;, line 348, in __init__ self._handle = _dlopen(self._name, mode)OSError: [WinError 126] 找不到指定的模块。During handling of the above exception, another exception occurred:Traceback (most recent call last): File &quot;train.py&quot;, line 3, in &lt;module&gt; from libsvm.python.svmutil import * File &quot;C:\Python36\lib\libsvm\python\svmutil.py&quot;, line 5, in &lt;module&gt; from svm import * File &quot;C:\Python36\lib\libsvm\python\svm.py&quot;, line 38, in &lt;module&gt; raise Exception(&apos;LIBSVM library not found.&apos;)Exception: LIBSVM library not found. 出错原因：在github上下载的libsvm中的libsvm.lib是win64版本的，而自己的python版本是32位的解决方案：方法1.更换python版本（太麻烦了，还要重新下载好多库）方法2.去万能宝库上下载对应版本的.whl文件，（不用安装）直接解压后找到libsvm.lib更换即可 2018-09-07 22:11:58 参考资料1.https://blog.csdn.net/rena521/article/details/51187981]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>libsvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim的使用]]></title>
    <url>%2F2018%2F06%2F23%2Fvim%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.光标移动h,j,k,l(空格):向左，下，上，右移动光标Ctrl+(f,b,d,u):屏幕向下移一页，向上移一页，向下移半页，向上移半页+-:下一行，上一行H,M,L:光标移动到这个屏幕的最上方，中央，最下方那一行的第一个字符G,nG,gg:移动都文档末，移动到第n行，移动到第一行n:向下移动n行 2.搜索替换/word:向光标之下寻找word?word:向光标之上寻找wordn,N:重复搜索（不变方向，改变方向） 参考资料1.http://www.runoob.com/linux/linux-vim.html]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git的使用]]></title>
    <url>%2F2018%2F06%2F08%2Fgit%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[git的一些命令配置用户名和邮箱12git config --global user.name "username"git config --global user.emil "useremil@xxx.com" 生成密钥ssh-keygen -t rsa添加远程仓库git remote add origin git@github.com:name/reponame.git 参考资料1.https://blog.csdn.net/csdn_blog_lcl/article/details/53172885]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中关于路径的知识]]></title>
    <url>%2F2018%2F06%2F02%2Fpython%E4%B8%AD%E5%85%B3%E4%BA%8E%E8%B7%AF%E5%BE%84%E7%9A%84%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[总结一下python中关于路径的一些知识点 1234567891011121314151617os.getcwd()#输出当前路径os.listdir()#输出当前路径下的所有文件夹名和文件名os.remove('filename.xxx')和os.unlink('filename.xxx')功能一样#删除文件filename.xxxos.rmdir('path')#删除目录（目录必须为空）os.removedirs('p1//p2//p3')#依次删除目录p3,p2,p1直到某一目录不为空os.chdir('path')#更改当前路径 参考资料1.https://www.cnblogs.com/yanglang/p/7610838.html2.https://blog.csdn.net/muwinter/article/details/77196261]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python类和实例的一些属性]]></title>
    <url>%2F2018%2F05%2F17%2Fpython%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[对于python中self,__name__,__init__()等的解释 1,self和__init__()self代表类的实例,如下：12345678910111213141516class Test: a,b='classa','classb'#类的属性 def __init__(self): self.b='selfb'#实例的属性 self.c='selfc'print(Test.a)print(Test.b)#-output:classa classb-访问类的属性a=Test()print(a.a)#-output:classa-通过实例访问类的属性print(a.b)#-output:selfb-当实例和类都具有某属性时,输出实例属性print(a.c)print(Test.c)#output 当实例和类有相同的属性时，如何通过实例访问类的属性呢？可以通过__class__访问 2,__class____class__是指实例所对应的类1234567891011121314151617# -*- coding: utf-8 -*-class Test: a='classa' print(count) def __init__(self): self.a='selfa' print(self) #-output:&lt;__main__.Test object at 0x055A1270&gt; print(self.__class__) #-output:&lt;class '__main__.Test'&gt;a=Test()print('实例a',a)#-output:&lt;__main__.Test object at 0x055A1270&gt;print('类Test',Test)#-output:&lt;class '__main__.Test'&gt;print(a.a,a.__class__.a)#-output:selfa classa 通过__init__()可以实现对类的实例的统计12345678910111213# -*- coding: utf-8 -*-class Test(object): count=0 def __init__(self): super(Test, self).__init__() self.__class__.count+=1if __name__=="__main__": a=Test() print(Test.count) b=Test() print(Test.count) Test() print(Test.count) 输出为123123 每创建一个Test类的实例,Test.count都加1 3,__dict____dict__是一个字典，键是属性名，值为属性值。类有自己的__dict__，类的实例也有自己的__dict__12345678910# -*- coding: utf-8 -*-class Test(object): classa='classa' def __init__(self): super(Test, self).__init__() self.selfb='selfb'if __name__=="__main__": print(Test.__dict__) a=Test() print(Test.__dict__) 输出为12&#123;&apos;__module__&apos;: &apos;__main__&apos;, &apos;classa&apos;: &apos;classa&apos;, &apos;__init__&apos;: &lt;function Test.__init__ at 0x04D03468&gt;, &apos;__dict__&apos;: &lt;attribute &apos;__dict__&apos; of &apos;Test&apos; objects&gt;, &apos;__weakref__&apos;: &lt;attribute &apos;__weakref__&apos; of &apos;Test&apos; objects&gt;, &apos;__doc__&apos;: None&#125;&#123;&apos;selfb&apos;: &apos;selfb&apos;&#125; 可见类Test有classa属性以及一些其他属性类Test的实例a只有selfb属性2018-05-23 14:54:58 参考资料1,https://docs.python.org]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3之模块]]></title>
    <url>%2F2018%2F04%2F28%2Fpython3%E4%B9%8B%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[关于python模块的一些问题 1.python3模块简单讲，一个模块就是一个*.py文件，这个文件里面可以定义类，函数，变量，也可以包含可执行代码。 2.模块的引入2.1import引入1import module1,[module2[,.........moduleN]] 一个模块只会被导入一次，不管执行了多少次import，这样可以防止导入模块被重复执行。 2.2from * import语句12from modname import name1,name2..........nameNfrom mod import func_1 这个声明不会把整个mod模块导入到当前命名空间中，它只会将mod里的func_1单个引入到执行这个声明的模块的全局符号表。 from … import * ：这样会把模块中的所有内容导入到当前命名空间，一般不建议使用，消耗内存空间，也容易出现未预知的问题。 3.搜索路径搜索顺序：当前目录-&gt;系统环境变量PATHONHOME-&gt;标准链接库目录通过sys.path可查看搜索路径123&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path[&apos;&apos;, &apos;C:\\Python36\\python36.zip&apos;, &apos;C:\\Python36\\DLLs&apos;, &apos;C:\\Python36\\lib&apos;, &apos;C:\\Python36&apos;, &apos;C:\\Python36\\lib\\site-packages&apos;] 4.命名空间变量是拥有匹配对象的名字（标识符）。命名空间是一个包含了变量名称（键）和它们各自相应的对象们（值）的字典。函数内用到全局变量要用global语句，否则会当作局部变量处理 其他问题:1.python模块里的可执行代码何时执行？当导入模块时，python顶层的代码会执行一次，若要重新执行模块的顶层代码需要通道reload()函数另外python3中的reload()需要从imp包中导入2.关于python模块循环引入的问题？ 参考资料1.https://www.cnblogs.com/zhangxinqi/p/7905103.html]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用神经网络识别手写数字[译]]]></title>
    <url>%2F2018%2F04%2F07%2F%E4%BD%BF%E7%94%A8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%AF%86%E5%88%AB%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%97-%E8%AF%91%2F</url>
    <content type="text"><![CDATA[使用神经网络识别手写数字python版本:python2 1.第一章人类的视觉系统是世界的奇迹之一，考虑如下的一串手写数字：大多数人毫不费力地将这些数字识别为504192。这种安逸是骗人的，在我们大脑的每个半球，人类都有一个主要的视觉皮层，也被称为$V_1$，含有1.4亿个神经元，它们之间有数以百亿计的联系。而且，人类视觉不仅涉及$V_1$，还涉及到整个系列的视觉皮质 - $V_2$，$V_3$，$V_4$和$V_5$ - 逐渐进行更复杂的图像处理。我们的大脑中有一台超级计算机，根据数亿年的演变进行调整，并且非常适合了解视觉世界。识别手写数字并不容易。相反，我们人类是惊人的，非常擅长理解我们的眼睛向我们展示的东西。但几乎所有这些工作都是在无意识中完成的。所以我们通常不会意识到我们的视觉系统解决问题有多复杂。如果您尝试编写计算机程序来识别上述数字，则视觉模式识别的难度就会变得明显。对于我们自己来说非常简单的事突然变得非常困难。关于我们如何识别形状的简单直觉 ——“一个9在顶部有一个循环，而在右下方有一个垂直的冲程” ——在算法上表达的结果并不是那么简单。当你试图精确地制定这样的规则时，你很快会迷失在例外和警告以及特殊情况之中。它似乎毫无希望。 神经网络用另一种方式解决这个问题。这个想法是采取大量的手写数字，称为训练示例，然后开发一个可以从这些训练示例中学习的系统。换句话说，神经网络使用这些例子来自动推断识别手写数字的规则。此外，通过增加训练示例的数量，网络可以了解更多关于手写的内容，从而提高其准确性。所以，虽然我只显示了上面的100个训练数字，但也许我们可以使用数千甚至数百万或数十亿个训练示例来构建更好的手写识别器。在本章中，我们将编写一个计算机程序，实现一个学习识别手写数字的神经网络。该程序只有74行，并且不使用特殊的神经网络库。但是这个简短的程序识别数字的准确率超过96％，且无需人工干预。此外，在后面的章节中，我们将开发出将精度提高到99％以上的想法。事实上，最好的商业神经网络现在非常好，银行用它来处理支票，邮局用它来识别地址。 我们专注于手写识别，因为它对于一般学习神经网络来说是一个很好的原型问题。作为原型，它迎来了一个甜蜜点：它很具有挑战性 - 识别手写数字并不是一件容易的事情 - 但它并不是一个非常复杂的解决方案或者巨大的计算能力。此外，这是开发深度学习等更先进技术的好方法。因此，在整本书中，我们会一再回顾手写识别的问题。在本书后面，我们将讨论如何将这些想法应用于计算机视觉中的其他问题，以及语音，自然语言处理和其他领域。 当然，如果本章的要点只是编写一个计算机程序来识别手写数字，那么本章将会更短！但在学习中，我们将提出许多关于神经网络的关键思想，包括两种重要类型的人工神经元（感知器和Sigmoid神经元）和神经网络的标准学习算法，称为随机梯度下降。在整个过程中，我重点解释为什么事情按照他们的方式完成，并且建立你的神经网络直觉。这需要比如果我刚刚介绍发生的事情的基本机制更长的讨论，但它是值得的，以便您获得更深的理解。在学习与收获中，直到本章结束时，我们将能够理解深度学习是什么，为什么它很重要。 1.1感知器（Perceptrons）什么是神经网络？首先，我将解释一种称为感知器的人造神经元。感知器是在20世纪50年代和60年代由科学家Frank Rosenblatt开发的，受到了Warren McCulloch和Walter Pitts早期工作的启发。今天，使用其他人造神经元模型更为常见 - 在本书中以及在神经网络上的大量现代工作中，使用的主要神经元模型是一种称为Sigmoid神经元的模型。我们马上就会去了解Sigmoid神经元。但要理解为什么Sigmoid神经元的如此定义，值得花时间先了解感知器。那么感知器如何工作？感知器需要几个二进制输入$x_1,x_2,x\ldots,$并且产生一个单一的二进制输出。在上图的例子中，感知器有三个输入$x_1,x_2,x_3$。一般来说，它也可以有更多或更少的输入。Rosenblatt提出了一个简单的规则来计算输出。他介绍了权重$w_1,w_2,\ldots,$表示各个输入对输出重要性的实数。神经元的输出，0或者1，由权重和$\sum_jw_jx_j$比阈值更大还是更小确定。就像权重一样，阈值是一个实数，它是神经元的一个参数。用更精确的代数术语来描述： output=\begin{cases} 0 & \text{如果$ \sum_jw_jx_j\le阈值 $}\\ 1 & \text{如果$ \sum_jw_jx_j\gt阈值 $} \end{cases}\tag{1}这就是感知器如何工作的全部！ 这是基本的数学模型。您可以考虑感知器的一种方式是，它是一种通过权衡证据来做出决定的设备。让我举个例子。这不是一个非常现实的例子，但它很容易理解，我们很快会得到更现实的例子。假设周末即将到来，你听说你的城市将会有一场奶酪节。你喜欢奶酪，并试图决定是否参加这个节日。您可以通过权衡三个因素来做出决定： 1.天气好吗？2.你的男朋友或女朋友是否想陪你？3.节日临近公共交通吗？ （你没有一辆车）。 我们可以用相应的二元变量$x_1,x_2$和$x_3$来表示这三个因子。例如，如果天气好，我们取$x_1=1$，如果天气不好，$x_1=0$。同样的，如果你的男友或女友也想去，$x_2=1$；$x_3$和公共交通也一样。 现在，假设你绝对喜欢奶酪，那么即使你的男朋友或女朋友不感兴趣并且节日很难到达，你也很乐意去参加这个音乐节。但是，也许你真的厌恶恶劣天气，如果天气不好，你不可能去参加这个节日。您可以使用感知器来对这种决策进行建模。一种方法是为天气选择权重$w_1=6$，对于其他条件$w_2=2$和$w_3=2$。$w_1$的值较大表示天气对你来说很重要，远远大于你的男友或女友是否加入你或公共交通的接近程度。最后，假设你为感知器选择了一个5的阈值。通过这些选择，感知器实现所需的决策模型，每当天气良好时输出1，当天气不好时输出0。无论你的男朋友还是女朋友想去，或者公共交通是否在附近，输出结果都没有区别。 通过改变权重和阈值，我们可以得到不同的决策模型。例如，假设我们选择了3的阈值。然后感知器会决定你应该在天气好的时候去参加音乐节，或者节日在公共交通附近，你的男朋友或女朋友愿意加入你。换句话说，这将是一个不同的决策模式。降低门槛意味着你更愿意去参加这个节日。 显然，感知器不是一个完整的人类决策模型！但是，这个例子说明了感知器如何权衡不同种类的证据以作出决定。似乎有理由认为，复杂的感知器网络可能会做出相当微妙的决定：在这个网络中，第一列感知器 - 我们称之为第一层感知器 - 通过权衡输入证据，做出三个非常简单的决定。第二层感知器呢？这些感知器中的每一个都通过对第一层决策结果进行权衡来做出决定。通过这种方式，第二层中的感知器可以在比第一层中的感知器更复杂和更抽象的层次上做出决定。第三层感知器可以做出更复杂的决定。通过这种方式，感知器的多层网络可以进行复杂的决策。 顺便说一下，当我定义感知器时，我说感知器只有一个输出。在感知器之上的网络看起来他们有多个输出。事实上，他们仍然是单一输出。多个输出箭头仅仅是一个有用的方式，表明感知器的输出被用作其他几个感知器的输入。它比绘制一条单一的输出线然后分裂更加简洁。2018-04-07 19:12:03让我们简化描述感知器的方式。条件$\sum_jw_jx_j\gt$阈值显得复杂，我们可以通过两个简单的记法简化它。第一个是把$\sum_jw_jx_j$写作一个点积，$w\cdot x\equiv\sum_jw_jx_j$，其中，$w$和$x$都是向量，他们分别包含权重和输入。第二个变化是移动阈值到等式的左边，并用感知器的偏置代替它，$b=-threshold$(阈值)。使用偏置代替阈值，感知器的规则可以被重新定义为： output=\begin{cases} 0 & \text{如果$ w\cdot x\le阈值 $}\\ 1 & \text{如果$ w\cdot x\gt阈值 $} \end{cases}\tag{2}\label{(2)}你可以将偏置看作衡量感知器输出1的容易程度。或者用更多的生物学术语来说，偏置是衡量让感知器触发的容易程度。对于具有非常大偏置的感知器，感知器输出1是非常容易的。但是如果偏置非常小，那么感知器很难输出1。显然，引入偏置只是我们描述感知器的一个小变化，但是我们稍后会看到它会导致进一步的符号简化。因此，在本书的其余部分我们不会使用阈值，我们将始终使用偏置。 我将感知器描述为衡量证据作出决定的一种方法。另一种可以使用感知器的方法是计算我们通常认为是最基础的基本逻辑函数（与，或，与非）。例如，假设我们有一个有两个输入的感知器，每个输入的权重是-2，和一个整体的偏置3，下图是我们的感知器：然后我们将看到输入[0,0]时，输出1，因为$(-2)\ast 0+(-2)\ast 0+3=3$是正数。在这里，引入$\ast$作为乘号。类似的计算能显示输入[0,1]和[1,0]会输出1.但是输入[1,1]将输出0。因此我们的感知器实现了与非门。 与非门示例显示我们可以使用感知器来计算简单的逻辑函数。实际上，我们可以使用感知器网络来计算任何逻辑函数。原因在于与非门是计算通用的，也就是说，我们可以在与非门外建立任何计算。例如，我们可以使用与非门来构建一个电路，该电路添加两个位$x_1$和$x_2$。若需要计算按位和，$x_1\oplus x_2$，以及当$x_1$和$x_2$都是1时进位位被设置为1，即进位位是位乘积$x_1x_2$：为了获得感知器的等效网络，我们用感知器替换所有与非门，其中两个输入的权重均为-2，整体偏差为3。这个感知器网络的一个值得注意的方面是，最左感知器的输出被用作最下感知器的双重输入。当我定义感知器模型时，我没有说是否允许这种双重输出到同一个地方。其实，这并不重要。如果我们不想允许这样的事情，那么可以简单地将这两条线合并成一个权重为-4的单一连接，而不是两个具有-2权重的连接。（如果你没有发现这一点，你应该停下来向自己证明这是相同的。）随着这种变化，网络看起来如下所示，所有未标记的权重等于-2，所有偏差等于3，单个权重为-4，如下所示：到目前为止，我一直在绘制像$x_1$和$x_2$这样的输入作为感知器网络左侧的变量。事实上，传统的做法是绘制额外的感知层-输入层-对输入进行编码：输入感知器的这种表示法，其中有输出，但没有输入，上图是一个简写。它实际上并不意味着是没有输入的感知器。要看到这个，假设我们确实有一个没有输入的感知器。那么加权总和$\sum_jw_jx_j$总是为零，所以对于感知器，当$b\gt0$将输出1，当$b\le0$则输出0。也就是说，感知器只会输出一个固定的值，而不是所需的值（在上面的例子中是$x_1$）。最好将输入感知器视为不是真正的感知器，而是将特定的单位简单地定义为输出所需的值$x_1,x_2,x_3\ldots$ 加法器实例演示了如何使用感知器网络来模拟包含许多与非门的电路。由于与非门在计算上是通用的，因此感知器对于计算也是普遍的。 感知器的计算普遍性同时令人放心和失望。这令人放心，因为它告诉我们，感知器网络可以像其他任何计算设备一样强大。但它也令人失望，因为它使得它看起来好像感知器仅仅是一种新型的与非门。这不是什么大新闻！ 但是，情况比这个观点表明的要好。事实证明，我们可以设计出可以自动调整人造神经元网络的权重和偏差的学习算法。这种调整是针对外部刺激而发生的，没有程序员的直接干预。这些学习算法使我们能够以与传统逻辑门完全不同的方式使用人造神经元。我们的神经网络不是明确地布局与非电路和其他门电路，而是简单地学会解决问题，因为有时候直接设计传统电路非常困难。2018-04-08 22:29:52 1.2Sigmoid神经元（Sigmoid neurons）学习算法听起来很棒。但是我们怎样才能为神经网络设计这样的算法呢？假设我们有一个想用来学习解决某个问题的感知器网络。例如，网络的输入可能是来自手写的数字扫描图像的原始像素数据。我们希望网络学习权重和偏差，以便网络正确地输出对数字的分类。要了解学习如何起作用，假设我们对网络中的一些权重（或偏差）进行小改动。我们想要的是，这种小的重量变化只会导致网络输出的相应变化很小。正如我们稍后会看到的，这个属性将使学习成为可能。简单来说，这就是我们想要的（显然这个网络太简单了，无法进行手写识别！）：如果权重（或偏差）的小变化确实只会导致输出的小变化，那么我们可以利用这个事实来修改权重和偏差，从而使我们的网络以我们想要的方式行为运行。例如，假设当网络应该是“9”时，网络错误地将图像分类为“8”。我们可以弄清楚如何对权重和偏差做一些小的改变，这样网络就会更接近将图像分类为“9”。然后我们再重复一遍，改变权重和偏差以产生更好的输出。网络将在学习。 问题是，当我们的网络包含感知器时，这不是要发生的。事实上，网络中任何单个感知器的权重或偏差的小改变有时会导致该感知器的输出完全翻转，例如从0到1。这个翻转可能会导致网络其他部分的行为以一种非常复杂的方式完全改变。因此，虽然现在您的“9”可能被正确分类，但网络在所有其他图像上的行为可能会以一些难以控制的方式完全改变。这使得很难看到如何逐渐修改权重和偏差，以使网络更接近所需的行为。也许有一些解决这个问题的巧妙方法。但是，我们如何才能获得感知器的学习网络并不明显。我们可以通过引入一种称为sigmoid神经元的新型人造神经元来克服这个问题。sigmoid神经元与感知器类似，但是经过修改使得它们的权重和偏差的小变化仅导致其输出的小变化。这是允许一个sigmoid神经元网络学习的关键事实。 好的，让我描述sigmoid神经元。我们将用描述感知器的相同方式描述sigmoid神经元：就像一个感知器，这个sigmoid神经元的输入为$X1,X2,\ldots$ 但这些输入不仅仅是0或1，而是可以取0和1之间的任何值。因此，例如，$0.638\ldots$是sigmoid神经元的有效输入。也就像感知器一样，sigmoid神经元对每个输入都有权重$w1,w2,\ldots$和整体偏差$b$。但输出不是0或1。取而代之的是$\sigma(w\cdot x+b)$,其中$\sigma$被称作sigmoid函数，它被定义为： \sigma(z)\equiv{1 \over {1+e^{-z}}}\tag{3}\label{(3)}为了更清楚地说明，具有输入$x_1,x_2,\ldots,$权重$w_1,w_2,\ldots,$的sigmoid神经元的偏置$b$为： {1 \over 1+exp({-\sum_jw_jx_j-b})}\tag{4}\label{(4)}乍一看，sigmoid神经元与感知器显得非常不同。如果你不熟悉sigmoid函数的代数形式，会感觉晦涩难以理解。事实上，在sigmoid神经元和感知器之间有许多相似之处，而sigmoid函数的代数形式更像一个技术细节，而不是真正的理解障碍。 为了理解它与感知器模型的相似之处，假设$z\equiv w\cdot x + b$是一个很大的正数，那么$e^{-z}\approx 0$，因此$sigma(z)\approx 1$。总之，当$z\equiv w\cdot x + b$是大的正数时，sigmoid神经元的输出接近1。就像一个感知器一样。相反，假设$z\equiv w\cdot x + b$是非常小的负数，那么$e^{-z}\to \infty$，而且$sigma(z)\approx 0$。因此当$z\equiv w\cdot x + b$是很小的负数时，sigmoid神经元的行为也接近一个感知器。只有当$ w\cdot x + b$的大小适中它的行为才会与感知器模型有很大区别。 关于$\sigma$函数的代数形式，我们应该怎样理解？事实上，$\sigma$的确切形式并不重要—重要的是这个函数的图形。下图是它的图形：这个形状是一个平滑的阶梯函数版本：事实上，如果$\sigma$函数是一个阶梯函数那么sigmoid神经元将是一个感知器，因为此时的输出0或者1取决于$w\cdot x+b$是正是负。如上所述，通过使用实际的$\sigma$函数，我们可以得到一个平滑的感知器。的确，$\sigma$函数的平滑性是至关重要的事实，而不是其详细的形式。$\sigma$函数的平滑性意味着权重的一个小变化$\Delta w_j$和偏置的小变化$\Delta b_j$在神经元的输出上也产生一个小变化$\Delta output$。事实上，通过微积分我们可以知道$\Delta output$很接近： \begin{eqnarray} \Delta output \approx \sum_j \frac{\partial output}{\partial w_j} \Delta w_j + \frac{\partial output}{\partial b} \Delta b \tag{5}\label{(5)} \end{eqnarray}总和超过所有权重，$w_j$，${\partial output\over \partial w_j}$和${\partial output\over \partial b}$分别表示$output$对$w_j$和$b$的偏导数。如果你不喜欢偏微分等一系列复杂的东西，也无需惊慌。虽然上面的表达看起来很复杂，但是所有的偏导数，其实都是在说一些非常简单的事情（这是一个非常好的消息）：$\Delta output$是关于权重的变化$\Delta w_j$和偏置的变化$\Delta b$的一个线性函数。这种线性使得很容易选择权重和偏差的小变化来实现任何想得到的输出的小变化。因此，尽管sigmoid神经元和感知器有很多相同的定性行为，但他们使它更容易弄清楚偏置和权重的变化如何改变输出的变化。 如果只是$\sigma$的形状重要，而不是它的特定形式，那么在等式$\color{lime}{\eqref{(3)}}$中我们为什么使用$\sigma$函数的特定形式呢？事实上，在本书后面我们偶尔会考虑一些其它的激活函数$f(\cdot )$的输出为$f(w\cdot x+b)$的神经元。当我们使用不同的激活函数时，主要的变化是方程$\color{lime}{\eqref{(5)}}$中偏导数的特定值改变。事实证明，当我们稍后计算这些偏导数时，使用$\sigma$将简化计算，仅仅因为指数在计算时具有特别的性质。无论如何，$\sigma$通常用于神经网络的工作，并且是本书中最常用的激活函数。 我们应该如何解释sigmoid神经元的输出？显然，感知器和sigmoid神经元之间的一个很大的区别是sigmoid神经元不仅输出0或1。它们可以输出0到1之间的任何实数，因此$0.173\ldots$和$0.689\ldots$等值是合法输出。 例如，如果我们想要使用输出值来表示输入到神经网络的图像中像素的平均强度，这可能很有用。但有时它可能有干扰。假设我们希望来自网络的输出指示“输入图像是9”或“输入图像不是9”。显然，如果输出是0或1，那么最容易做到这一点，就像感知器一样。但实际上，我们可以设定一个约定来处理这个问题，例如，通过决定将至少为$0.5$的任何输出解释为指示“9”，并且将小于$0.5$的任何输出解释为指示“不是9 ”。我会一直明确地说出我们何时使用这样的惯例，所以它不应该引起任何混淆。 1.3练习 第一部分，sigmoid神经元模拟感知器假设我们将所有的权重和偏差放在感知器网络中，并将它们乘以一个正常数$c\gt 0$。证明网络的行为不会改变。 第二部分，sigmoid神经元模拟感知器假设我们具有与最后一个问题相同的设置的感知器网络。还假设已经选择了感知器网络的整体输入。我们不需要实际的输入值，我们只需要对输入进行修改。假设权重和偏差是这样的：对于网络中任何特定感知器的输入$x$，$w\cdot x+b\neq 0$。现在用sigmoid神经元替换网络中的所有感知器，并将权重和偏差乘以正常数$c\gt 0$。证明在极限$c \rightarrow \infty$时，这个S形神经元网络的行为与感知器网络完全相同。当一个感知器的$w\cdot x+b=0$时，这怎么会失败？ 2018-04-11 15:47:15 1.4神经网络的体系结构在下一节中，我将介绍一个可以对手写数字进行分类的神经网络。为此做好准备，让我们为网络的不同部分命名，这有助于解释一些术语。假设我们有网络：如前面提到的，该网络中最左边的层称为输入层，层内的神经元称为输入神经元。最右边或输出层包含输出神经元，或者，在这种情况下为单个输出神经元。中间层被称为隐藏层，因为该层中的神经元既不是输入也不是输出。“隐藏”这个词或许听起来有点神秘 - 第一次听到这个词我认为它必须有一些深刻的哲学或数学意义 - 但它只不过意味着“不是输入或输出”。上面的网络只有一个隐藏层，但有些网络有多个隐藏层。例如，以下四层网络有两个隐藏层：有些令人困惑的是，由于历史原因，这种多层网络有时被称为多层感知器或MLPs，尽管是由sigmoid神经元组成的，而不是感知器。我不打算在本书中使用MLP术语，因为我觉得它很混乱，但是想警告你它的存在。 网络中输入和输出层的设计通常很简单。例如，假设我们试图确定手写图像是否描绘了“9”。设计网络的一种自然方式是将图像像素的强度编码成输入神经元。如果图像是$64 \times 64$的灰度图像，则我们有$4096 = 64 \times 64$的输入神经元，强度在0和1之间适当缩放。输出层将只包含一个神经元，输出值小于$0.5$表示“输入图像不是9”，大于$0.5$的值表示“输入图像是9”。虽然神经网络的输入和输出层的设计通常是直截了当的，但隐藏层的设计可能有相当的艺术。特别是，用几个简单的经验法则来概括隐藏层的设计过程是不可能的。相反，神经网络研究人员已经为隐藏层开发了许多设计启发式方法，这些方法可以帮助人们从他们的网络中获得他们想要的行为。例如，可以使用这种启发式方法来帮助确定如何根据训练网络所需的时间权衡隐藏层的数量。本书稍后会介绍几种这样的设计启发式。 到目前为止，我们一直在讨论神经网络，其中一层的输出被用作下一层的输入。这种网络被称为前馈神经网络。这意味着网络中没有环路 - 信息总是前馈，永不反馈。如果我们确实有循环，最终会出现$\sigma$函数的输入取决于输出的情况。这很难理解，所以我们不允许这样的循环。 但是，还有其他可以反馈回路的人工神经网络模型。这些模型被称为递归神经网络。这些模型中的想法是让神经元在静止之前在有限的时间内发射。这种射击可以刺激其他神经元，这些神经元可能会在稍后发射，持续时间也有限。这会导致更多的神经元发射，所以随着时间的推移，我们会得到一连串的神经元发射。循环不会在这样的模型中产生问题，因为神经元的输出仅在稍后时间而不是瞬时影响其输入。 递归神经网络比前馈网络的影响力小，部分原因是递归网络的学习算法（至少到目前为止）不那么强大。但递归网络仍然非常有趣。他们在精神上更接近我们的大脑如何工作，而不是前馈网络。有可能的是，递归网络可以解决重要问题，而这些问题只能通过前馈网络很难解决。 1.5一个简单的网络来分类手写数字定义了神经网络之后，让我们回到手写数字识别的实现。我们可以将识别手写数字的问题分成两个子问题。首先，我们想要一种将包含许多数字的图像分解为一系列单独图像的方式，每个图像都包含一个数字。例如，我们想要分解这个图片：分成六个独立的图像，我们人类轻松地解决了这个分割问题，但是计算机程序正确分割图像是具有挑战性的。举例来说，我们希望我们的程序能够识别出上面的第一个数字，是一个5。 我们将着重编写一个程序来解决第二个问题，即对单个数字进行识别。我们这样做是因为事实证明，一旦你有一种很好的分类单个数字的方法，分割问题就不难解决了。有很多方法可以解决分割问题。一种方法是尝试许多不同的分割图像的方式，使用一个数字分类器对每个分割方式进行评分。如果那个数字分类器对所有数字的分类准确率都很高，则分割方式得到高分;如果分类器在一个或多个数字分类中遇到很多问题，则分数较低。这个想法是，如果分类器在某处遇到麻烦，那么可能会遇到麻烦的原因是分割选择不正确。 要识别单个数字，我们将使用三层神经网络：网络的输入层包含编码输入像素值的神经元。正如下一节所讨论的，我们的网络训练数据将包含许多扫描$28×28$像素的手写数字图像，因此输入层包含$784=28×28$个神经元。为了简单起见，我省略了上图中784个输入神经元中的大部分神经元。输入像素是灰度值，值为0.0表示白色，值为1.0表示黑色，在0和1之间的值表示逐渐变暗的灰色阴影。 网络的第二层是一个隐藏层。我们用$n$表示隐藏层中神经元的数量，我们将尝试$n$的不同值。显示的例子是了一个小的隐藏层，只包含$n=15$个隐藏层神经元。 网络的输出层包含10个神经元。如果第一个神经元触发，即输出$\approx 1$，那么这将表明网络认为该数字是0。如果第二个神经元触发，则表明网络认为该数字是1。一次类推。更精确一点，我们从0到9对输出神经元进行编号，并找出哪个神经元具有最高的激活值。如果这个神经元是第6个神经元，那么我们的网络会猜测输入数字是6。其他输出神经元亦是如此。 你可能想知道为什么我们使用1010个输出神经元。毕竟，网络的目标是告诉我们输入图像对应于哪个数字$(0,1,2,\ldots 9)$。看似自然的做法是只使用4个输出神经元，根据神经元的输出是接近于0还是接近1来将每个神经元视为二进制值。四个神经元足以对答案进行编码，因为$2^4=16$比输入数字的个数10多。为什么我们的网络应该使用10个神经元呢？这不是没有效率吗？最终的理由来自于经验：我们可以尝试两种网络设计，结果发现，对于这个特定的问题，具有10个输出神经元的网络学习识别数字比具有4个输出神经元的网络更好。但是这让我们想知道为什么使用10输出神经元的效果更好。是否有一些启发式方法会提前告诉我们应该使用10个输出编码而不是4输出编码？ 通过理解我们为什么这样做，它有助于根据第一原则思考神经网络正在做什么。首先考虑使用10个输出神经元的情况。让我们专注于第一个输出神经元，一个试图决定数字是否为0的神经元。它通过权衡来自神经元隐藏层的证据来做到这一点。那些隐藏的神经元在干什么？很好，为了说明这一点，假设隐藏层中的第一个神经元检测是否存在如下图像：它可以通过对与图像重叠的输入像素进行大量加权来实现，并且只对其他输入轻微加权。以类似的方式，为了论证的缘故，我们假设隐藏层中的第二，第三和第四个神经元检测是否存在以下图像：正如您可能已经猜到的那样，这四幅图像一起组成了我们在前面显示的数字中看到的0图像：所以如果这四个隐藏的神经元都在触发，那么我们可以得出这个数字是0的结论。当然，这不是我们可以用来得出图像是0的唯一证据，我们可以通过许多其他方式（通过翻转上述图像或轻微扭曲）合理地获得0。但似乎可以肯定地说，至少在这种情况下，我们认为输入是0。2018-04-12 22:17:33假设神经网络按这种方式工作，我们合理的解释为什么$10$个输出神经元更好，而不是$4$个。如果我们有$4$个输出神经元，那么第一个输出神经元将试着确定什么是数字图像中最重要的位。这里没有很容易的方式来得到如上图所示简单的形状的重要位。很难想象，这里存在任何一个很好的根据来说明数字的形状组件与输出重要位的相关性。 现在，就像所说的那样，这就是一个启发式。没有什么能说明三层神经网络会按照我描述的那样运作，这些隐含层能够确定简单的形状组件。可能一个更聪明的学习算法将找到权重赋值以便我们使用$4$个输出神经元。但是我描述的这个启发式方法已经运作很好，能够节约很多时间来设计更好的神经元网络架构。 1.6练习有一个方法能够对上面的三层网络增加一个额外层来确定数值位表示。这个额外层将先前输出层转换为二进制表示，就像下图说明一样。找到这层新的输出神经元权重和偏移。假定第$3$层神经元（例如，原来的输出层）正确的输出有至少$0.99$的激励值，不正确的输出有小于$0.01$的激励值。 1.7梯度下降学习算法现在我们已经有一个设计好的神经网络，它怎样能够学习识别数字呢?首要的事情是我们需要一个用于学习的数据集——也叫做训练数据集。我们将使用MNIST数据集，它包含成千上万的手写数字图像，同时还有它们对应的数字分类。MNIST的名字来源于NIST（美国国家标准与技术研究所）收集的两个修改后的数据集。这里是一些来自于MNIST的图像：就像你看到的，事实上这些数字和本章开始展示的用于识别的图像一样。当然，测试我们的网络时候，我们会让它识别不在训练集中的图像！ MNIST数据来自两部分。第一部分包含60000幅用于训练的图像。这些图像是扫描250位人员的手写样本得到的，他们一半是美国人口普查局雇员，一半是高中学生。这些图像都是28乘28像素的灰度图。MNIST数据的第二部分包含10000幅用于测试的图像。它们也是28乘28的灰度图像。我们将使用这些测试数据来评估我们用于学习识别数字的神经网络。为了得到很好的测试性能，测试数据来自和训练数据不同的250位人员（仍然是来自人口普查局雇员和高中生）。 这帮助我们相信这个神经网络能够识别在训练期间没有看到的其他人写的数字。 我们将使用符号$x$来表示训练输入。可以方便的把训练输入$x$当作一个$28 \times 28 = 784$维的向量。每一个向量单元代表图像中一个像素的灰度值。我们将表示对应的输出为$y = y(x)$，其中$y$是一个$10$维向量。比如，如果一个特殊的训练图像$x$，表明是$6$，那么$y(x) = (0, 0, 0, 0, 0, 0, 1, 0, 0,0)^T$就是网络期望的输出。注意$T$是转置运算，将一个行向量转换为列向量。 我们想要的是一个能让我们找到合适的权重和偏移的算法，以便网络输出$y(x)$能够几乎满足所有训练输入$x$。为了量化这个匹配度目标，我们定义了一个代价函数: C(w,b)\equiv \frac {1}{2n}\sum_x{||y(x)-a||}^2\tag{6}\label{(6)}这里，$w$表示网络中的所有权重，$b$是所有偏移，$n$训练输入的总数，$a$是网络输入为$x$时的输出向量，总和是对所有输入$x$进行的累加。当然输出$a$取决于$x$，$w$和$b$，但是为了符号简化，我没有指明这种依赖关系。符号$| v |$只是表示向量$v$的长度。我们称$C$为二次型代价函数；它有时候也叫做均方误差或MSE。检验二次型代价函数，我们能看到$C(w,b)$是一个非负值，因为求和中的每一项都是非负的。此外，对于所有训练数据$x$，$y(x)$和输出$a$近似相等时候，$C(w,b)$会变得很小，例如，$C(w,b) \approx 0$。因此如果我们的训练算法能找到合理的权重和偏移使得$C(w,b) \approx 0$，这将是一个很好的算法。相反，如果$C(w,b)$很大——这意味着$y(x)$和大量输出$a$相差较大。所以训练算法的目标就是找到合适的权重和偏移来最小化$C(w,b)$。换句话说，我们想找到一组权重和偏移集合，使得代价函数值尽可能小。我们将使用梯度下降算法来实现。 为什么引入二次型代价函数？毕竟，我们不是主要关注在网络对多少图像进行了正确分类？为什么不直接最大化这个数值，而不是最小化一个像二次型代价函数一样的间接测量值？问题就在于正确识别的图像数量不是权重和偏移的平滑的函数。对于大多数，权重和偏移的很小改变不会让正确识别的图像数量值有任何改变。这就使得很难指出如何改变权重和偏移来提高性能。如果我们使用一个像二次型的平滑代价函数，它将很容易指出如何细微的改变权重和偏移来改进代价函数。这就是为什么我们首先关注在最小化二次型代价函数，而且只有那样我们才能检测分类的准确性。 即使我们想使用一个平滑的代价函数，你可能仍然想知道为什么在等式$\color{lime}{\eqref{(6)}}$中选择了二次型代价函数。它难道不是一个临时的选择？也许如果我们选择一个不同的代价函数，我们将获取到完全不同的最小化权重和偏移？这是一个很好的考虑，后面我们将回顾这个代价函数，并且进行一些改变。但是，这个等式$\color{lime}{\eqref{(6)}}$中的二次型代价函数对理解神经网络学习基础非常好，因此目前我们将坚持使用它。 简要回顾一下，我们训练神经网络的目标是找出能最小化二次型代价函数$C(w, b)$的权重和偏移。这是一个适定问题，但是它会产生许多当前提出的干扰结构——权重$w$和偏移$b$的解释、背后隐藏的$\sigma$函数、网络架构的选择、MNIST等等。结果说明我们能通过忽略许多这类结构来理解大量内容，且只需要集中在最小化方面。因此现在我们将忘掉所有关于代价函数的特殊形式，神经网络的连接关系等等。相反，我们将想象成只简单的给出一个具有许多变量的函数，且我们想要最小化它的值。我们将开发一个新技术叫梯度下降，它能被用来解决这类最小化问题。然后我们将回到神经网络中这个想最小化的特殊函数。 好的，假设我们将最小化一些函数$C(v)$。它可能是具有许多变量$v = v_1, v_2, \ldots$的任意真实值函数。请注意，我们将用$v$替换符号$w$和$b$来强调它可以适合任意一个函数——我们并不是一定在神经网络的背景下考虑。为了最小化$C(v)$，可以把$C$想象成只具有两个变量，即$v_1$和$v_2$：我们想要找到怎样才能使$C$达到全局最小化。现在，当然，对上面绘制的函数，我们能看出该图中最小化位置。从这种意义上讲，我可能展示了一个太简单的函数！一个通常的函数$C$可能由许多变量构成，并且很难看出该函数最小化位置在哪里。 一种解决办法就是使用微积分来解析地找到这个最小值。我们能计算导数，然后使用它们来找到$C$函数最小极值的位置。当$C$只有一个或少量变量时，这个办法可能行得通。但是当我们有许多变量时，这将变成一场噩梦。且对于神经网络，我们通常需要更多的变量——最大的神经网络在极端情况下，具有依赖数十亿权重和偏移的代价函数。使用微积分来求最小值显然行不通！ (在断言我们通过把$C$当作只具有两个变量的函数来获得领悟后，我将用两段第二次转回来，并且说：“嘿，一个具有超过两个变量的函数是什么呢？”，对此很抱歉。请相信我，把$C$想象成只具有两个变量的函数对我们理解很有帮助。有时候想象会中断，且最后两段将处理这种中断。好的数学思维通常会涉及应付多个直观想象，学会什么时候合适使用每一个想象，什么时候不合适。) Ok，所以用微分解析的方法行不通。幸运的是，我们可以通过一种非常直观的类比来找到一种“行得通”的算法。首先将我们的函数看作是一个凹形的山谷。（瞄一眼上面的插图，这种想法应该是很直观的。）好，现在让我们想象有一个小球沿着山谷的坡面向低处滚。生活经验告诉我们这个小球最终会到达谷底。或许我们可以采用类似的思路找到函数的最小值？好，首先我们将随机选取一个点作为这个（想象中的）球的起点，然后再模拟这个小球沿着坡面向谷底运动的轨迹。我们可以简单地通过计算 $C$ 的偏导数（可能包括某些二阶偏导数）来进行轨迹的模拟——这些偏导数蕴涵了山谷坡面局部“形状”的所有信息，因此也决定了小球应该怎样在坡面上滚动。 根据我刚才所写的内容，你可能会以为我们将从小球在坡面上滚动的牛顿运动方程出发，然后考虑重力和坡面阻力的影响，如此等等……实际上，我们不会把“小球在坡面滚动”的这一类比太过当真——毕竟，我们我们的初衷是要设计一种最小化 $C$ 的算法，而不是真地想精确模拟现实世界的物理定律！“小球在坡面滚动”的直观图像是为了促进我们的理解和想象，而不应束缚我们具体的思考。所以，与其陷入繁琐的物理细节，我们不妨这样问自己：如果让我们来当一天上帝，那么我们会怎样设计我们自己的物理定律来引导小球的运动？我们该怎样选择运动定律来确保小球一定会最终滚到谷底？ 为了将这个问题描述得更确切，现在让我们来想想，当我们将小球沿着 $v_1$ 方向移动一个小量$\Delta v_1$，并沿着 $v_2$ 方向移动一个小量 $\Delta v_2$ 之后会发生什么。微分法则告诉我们，$C$ 将作如下改变: \Delta C\approx \frac{\partial C}{\partial v_1}\Delta v_1+ \frac{\partial C}{\partial v_2}\Delta v_2 \tag{7}\label{(7)}2018-09-09 20:05:12我们将设法选择 $\Delta v_1$ 和 $\Delta v_2$ 以确保 $\Delta C$ 是负数，换句话说，我们将通过选择 $\Delta v_1$ 和 $\Delta v_2$ 以确保小球是向着谷底的方向滚动的。为了弄清楚该怎样选择 $\Delta v_1$ 和 $\Delta v_2$，我们定义一个描述 $v$ 改变的矢量 $\Delta v \equiv (\Delta v_1, \Delta v_2)^T$，这里的 $T$ 同样是 转置（transpose）算符，用来将一个行矢量转化为列矢量。我们还将定义 $C$ 的“梯度”，它是由 $C$ 的偏导数构成的矢量，$\left(\frac{\partial C}{\partial v_1}, \frac{\partial C}{\partial v_2}\right)^T$ 。我们将“梯度”矢量记为 $\nabla C$，即： \nabla C\equiv \left( \frac{\partial C}{\partial v_1}, \frac{\partial C}{\partial v_2} \right)^T \tag{8}\label{(8)}很快我们将会用 $\Delta v$ 和梯度 $\nabla C$ 来重写 $\Delta C$ 的表达式。在这之前，为了避免读者可能对“梯度”产生的困惑，我想再多做一点解释。当人们首次碰到$\nabla C$这个记号的时候，可能会想究竟该怎样看待$\nabla$这个符号。$\nabla$的含义到底是什么？其实，我们完全可以把$\nabla C$整体看作是单一的数学对象——按照上述公式定义的矢量，仅仅是偶然写成了用两个符号标记的形式。根据这个观点，$\nabla$像是一种数学形式的旗语，来提醒我们“嘿，$\nabla C$是一个梯度矢量”，仅此而已。当然也有更抽象的观点，在这种观点下，$\nabla$被看作是一个独立的数学实体（例如，被看作一个微分算符），不过我们这里没有必要采用这种观点。使用上述定义，$\Delta C$ 的表达式 (7) 可以被重写为： \Delta C\approx \nabla C \cdot \Delta v \tag{9}\label{(9)}这个方程有助于我们理解为什么 $\nabla C$ 被称为“梯度”矢量：$\nabla C$ 将 $v$ 的改变和 $C$ 的改变联系在了一起，而这正是我们对于“梯度”这个词所期望的含义。然而，真正令我们兴奋的是这个方程让我们找到一种 $\Delta v$ 的选择方法可以确保 $\Delta C$ 是负的。具体来说，如果我们选择 \Delta v=-\eta \nabla C \tag{10}\label{(10)}这里 $\eta$ 是一个正的小参数，被称为“学习率”（learning rate)。那么由方程$\color{lime}{\eqref{(9)}}$可知$\Delta C \approx -\eta \nabla C \cdot \nabla C = -\eta ||\nabla C||^2$。如果我们根据公式$\color{lime}{\eqref{(10)}}$指定 $v$ 的改变，由于 $|| \nabla C ||^2 \geq 0$ ，它确保了 $\Delta C \leq 0$，即 $C$ 的值将一直减小，不会反弹。（当然要在近似关系$\color{lime}{\eqref{(9)}}$ ) 成立的范围内）。这正是我们期望的性质！因此，我们将在梯度下降算法（gradient descent algorithm）中用公式 $\color{lime}{\eqref{(10)}}$来定义小球的“运动定律”。也就是说，我们将用公式$\color{lime}{\eqref{(10)}}$来计算 $\Delta v$ 的值，然后将小球的位置 $v$ 移动一小步： v \to v'=v - \eta \nabla C \tag{11}\label{(11)}然后，我们使用这一规则再将小球移动一小步。如果我们不断这样做，$C$ 将不断减小，符合期望的话，$C$ 将一直减小到全局最小值。 总之，梯度下降算法（gradient descent algorithm）是通过不断计算梯度$\nabla C$，然后向着梯度相反的方向小步移动的方式让小球不断顺着坡面滑向谷底。这个过程可以形象地用下图表示：注意：采用这一规则，梯度下降算法并没有模拟真实的物理运动。在现实世界，小球具有动量，而动量可能让小球偏离最陡的下降走向，甚至可以让其暂时向着山顶的方向逆向运动。只有考虑了摩擦力的作用，才能确保小球是最终落在谷底的。但这里，我们选择$\Delta v$的规则却是说“立马给我往下滚”，而这个规则仍然是寻找最小值的一个好方法！ 为了让“梯度下降法”能够正确发挥作用，我们必须选择一个足够小的“学习率” $\eta$ 以确保方程$\color{lime}{\eqref{(9)}}$是一个好的近似。如果我们不这样做，最终可能会导致 $\Delta C &gt; 0$，这当然不是我们想要的。与此同时，我们也不希望 $\eta$ 太小，因为η太小的话每一步的 $\Delta v$ 就会非常小, 从而导致梯度下降算法的效率非常低。在实际运用过程中，$\eta$经常是变化的从而确保不仅方程$\color{lime}{\eqref{(9)}}$是好的近似，而且算法也不会太慢。后面我们将会理解具体的做法。 前面我们已经解释了当函数 $C$ 仅仅依赖两个变量时的梯度下降算法。但其实，当 $C$ 依赖更多变量的时候，前面所有的论述依然成立。具体来说，假设函数 $C$ 依赖$m$个变量， $v_1,\ldots,v_m$，那么由微小改变 $\Delta v = (\Delta v_1, \ldots, \Delta v_m)^T$ 引起的 $C$ 的变化$\Delta C$是: \Delta C\approx \nabla C\cdot \Delta v \tag{12}\label{(12)}这里梯度矢量 $\nabla C$ 定义为: \nabla C\equiv \left( \frac{\partial C}{\partial v_1},\ldots ,\frac{\partial C}{\partial v_m} \right)^T \tag{13}\label{(13)}类似于两个自变量的情形，我们可以选择 \Delta v=-\eta \nabla C \tag{14}\label{(14)}那么就可以确保由公式$\color{lime}{\eqref{(12)}}$得到的 $\Delta C$ 是负的。这给了我们一种沿着梯度找到最小值的方法，即使 $C$ 依赖于很多变量。即通过不断重复地使用以下更新规则， v \to v'=v - \eta \nabla C \tag{15}\label{(15)}你可以把这种更新规则看作是“梯度下降算法”的定义。它给了我们一种不断改变 $v$ 的位置从而找到函数 $C$ 最小值的方法。这一规则并不总是有效——有些情况可能会导致出错，阻止梯度下降算法找到 $C$ 的全局最小值。在后面的章节我们会回过头来讨论这种可能性。不过，在实际应用中，梯度下降算法常常非常有效，并且在神经网络中，我们发现它也是一种最小化代价函数（cost function）的强有力方法，因此也有助于神经网络的学习。 的确，从某种意义上说梯度下降其实是寻找最小值的最佳策略。假设我们正试图通过移动一小步 $\Delta v$ 来让函数 $C$ 尽可能地减小。这等价于要要最小化 $\Delta C \approx \nabla C \cdot \Delta v$。我们将限定移动步幅的大小，即令 $|| \Delta v || = \epsilon$ 其中 $\epsilon &gt; 0$ 是一个固定的小量. 换句话说，我们想移动步长限定的一小步，并试图找到一个移动方向能够让C尽可能减小。可以证明这里最小化$\nabla C \cdot \Delta v$的$\Delta v$选择是 $\Delta v = - \eta \nabla C$, 这里 $\eta = \epsilon / ||\nabla C||$ 是由步长约束 $||\Delta v|| = \epsilon$ 所要求的。因此梯度下降可以被认为是一种沿着 $C$ 局域下降最快的方向一步一步向前走，从而找到最小值的方法。 练习1.证明上面最后一段的断言。提示：如果你还不熟悉柯西-施瓦茨不等式，你最好学习一下，这会对你很有帮助。 2.我们阐述当$C$有两个变量时的梯度下降，也阐述了超过两个变量的梯度下降。当$C$只有一个变量时候，会发生什么呢？你能提供在一个维度上梯度下降的几何解释吗？ 人们调研过很多从梯度下降变种而来的算法，包括精确模仿小球在真实物理世界运动的方法。这些模仿小球真实物理运动的方法有一些优点，但是也有一个显著的缺点：需要计算 $C$ 的二阶偏导数，而那样的话，计算成本会很高。为了看清楚为什么计算成本会很高，假设我们要计算所有的二阶偏导数 $\partial^2 C/ \partial v_j \partial v_k$。 如果这里需要计算的 $v_j$ 变量有一百万个，我们就要计算大概万亿（百万的平方）量级的二阶偏导数。这个计算成本非常高。 正因为上面所说的，人们搞出不少小技巧来避免计算成本过高的问题，同时，寻找梯度下降的替代算法也是非常活跃的研究领域。不过，本书将始终把梯度下降（及其变种）算法作为我们训练神经网络的主要方法。 我们怎样把梯度下降应用于神经网络的学习过程呢？具体思路是用梯度下降来寻找权重（weights）$w_k$ 和 偏移（bias） $b_l$ ，从而最小化代价函数$\color{lime}{\eqref{(6)}}$。为了看得更清楚，我们将梯度下降更新规则中的变量$v_j$用权重和偏移替换，进行重新表述。换句话说，我们现在的“位置”有 $w_k$ 和 $b_l$ 这些分量, 而梯度矢量 $\nabla C$ 也具有相应的分量 $\partial C / \partial w_k$ 和 $\partial C / \partial b_l$。将梯度下降规则用这些分量的形式写出来，我们有 w_k \to w_k'=w_k - \eta \frac{\partial C}{\partial w_k} \tag{16}\label{(16)} b_l \to b_l'=b_l - \eta \frac{\partial C}{\partial b_l} \tag{17}\label{(17)}通过不断重复应用这一更新规则，我们可以“从山上滚下来”，符合预期的话，我们将找到代价函数的最小值。换句话说，这个规则可以用于神经网络的学习过程。 在运用梯度下降规则的时候会碰到许多挑战难题。在后面的章节我们会仔细研究这些困难。但这里我只想提及其中的一个难题。为了更好地理解是什么难题，让我们回过头来看一下公式$\color{lime}{\eqref{(6)}}$定义的二次型代价函数。注意到这个代价函数具有形式$C = \frac{1}{n} \sum_x C_x$, 即，每一个训练样例误差 $C_x \equiv \frac{||y(x)-a||^2}{2}$ 的平均。实际上，为了计算梯度 $\nabla C$ ，我们需要对每个训练输入（trainning input）分别计算其梯度 $\nabla C_x$，然后再对它们求平均。不幸的是，如果训练输入的样本数量非常大，那么这样会消耗很多时间，因此导致神经网络的学习过程非常慢。 有一个可用于加速学习过程的办法被称作 “随机梯度下降”（stochastic gradient descent）。 这个办法是通过随机选择训练输入的少量样本，并只计算这些样本的$\nabla C_x$的平均值来估算梯度 $\nabla C$。通过计算这些少量样本的平均值，我们可以很快估算出梯度$\nabla C$的真实值，从而加速梯度下降过程，即加速神经网络的学习过程。 具体来说， 首先“随机梯度下降” 要随机挑出 $m$（一个较小的数目）个训练输入。我们将这些随机的训练输入标记为 $X_1,X_2…X_m$, 并将它们称为 一个 “小组”（mini-batch）。假设样本数$m$足够大，我们预计这个随机小组 $\nabla C_{X_j}$ 的平均值应该和所有 $\nabla C_x$ 的平均值大致相等，即 \frac{\sum_{j=1}^m\nabla C_{X_j}}{m} \approx \frac{\sum_x\nabla C_x}{n} = \nabla C \tag{18}\label{(18)}这里第二个求和符号表示对整个训练数据集的求和。交换等号两边的顺序，我们有 \nabla C \approx \frac{1}{m}\sum_{j=1}^{m}\nabla C_{X_j} \tag{19}\label{(19)}这个公式明确了我们可以通过仅仅计算随机选择的“小组”梯度来估算整体的梯度值。 为了将其和神经网络的学习过程直接联系起来，假设我们用 $w_k$ 和 $b_l$ 标记神经网络中的权重（weights）和 偏移（biases），那么随机梯度下降的工作方式为：随机挑出一“小组”训练输入，并用如下方式来训练 w_k \to w_k'=w_k - \frac{\eta}{m} \sum_j\frac{\partial C_{X_j}}{\partial w_k} \tag{20}\label{(20)} b_l \to b_l'=b_lk - \frac{\eta}{m} \sum_j\frac{\partial C_{X_j}}{\partial b_l} \tag{21}\label{(21)}这里的求和是对当前小组里的所有训练样本 $X_j$ 进行的。然后我们再随机挑出另一小组进行训练。如此反复下去，直到我们用尽了所有的训练输入。这个过程被称为完成了一“代”（epoch）训练。到那个时候，我们就可以重新开始另一代训练。 有的时候，我们需要注意：人们在标定代价函数(cost function)和对权重、偏移进行“组”(mini-batch)更新时所采用的惯例可能有所差异。公式$\color{lime}{\eqref{(6)}}$中，我们用了一个 $\frac{1}{n}$ 的因子对整体代价函数进行了标定。有时候，人们会忽略这个 $\frac{1}{n}$ 因子，即对所有训练样例“求和”而不是“求平均”。这一点在训练样例总数不能提前确定的时候非常有用，比如当更多的训练数据在不断实时产生的时候就会发生这种情况。同样类似，公式$\color{lime}{\eqref{(20)}}$和$\color{lime}{\eqref{(21)}}$中的“组”更新规则，有时候也会忽略求和前面的$\frac{1}{m}$因子。从概念上说，两者几乎没什么不同，因为这等价于重新标定了学习率 $\eta$ 而已。不过当我们在仔细对比不同的研究工作时，需要对此留心一点。 我们可以将随机梯度下降看做是某种类似于民意调查的过程：将梯度下降应用于一“小组”样例要比应用于全部样例要容易得多，就如同采样民意调查要比全民公投要容易得多。例如，在MNIST样例中，整个训练集的样本数 $n=60000$ 个，而比如说我们选定的“小组”样本数为$m=10$个。这意味着我们在估算梯度的时候会快$6000$倍！当然，估算结果不一定精确——因为有统计涨落的误差——不过，我们不需要它精确：因为我们关心的仅仅是这个过程是不是整体向着$C$减小的方向在走，而不是要严格计算出梯度值。实际上，随机梯度下降在训练神经网络的过程中是非常常见和有效的手段，也是本书将要演绎的许多训练技巧的基础。练习梯度下降的一种极端方式是使用大小为1的“小组”。也就是，给定一个训练输入$x$，我们按照规则$w_k \rightarrow w_k’ = w_k - \eta \partial C_x / \partial w_k$和$b_l \rightarrow b_l’ = b_l - \eta \partial C_x / \partial b_l$来更新权重和偏差。然后选择另外一个训练输入，再来更新权重和偏差。反复这样，这个过程被称为在线，在线或增量学习。在线学习中，神经网络每次从一个训练输入中进行学习（就像人一样）。请指出在线学习的优点和缺点，相对于具有“小组”大小为$20$的随机梯度下降算法。 好，这一节的最后，我们来讨论一个对于刚刚接触梯度下降算法的人常有的困扰。在神经网络中，代价函数 $C$ 当然依赖于很多变量，即，所有的权重和偏移。因此，从某种意义上说，$C$ 定义了一个非常非常高维空间中的曲面。有些人可能会觉得；“嗯，我需要想象这些额外的维度”，然后开始担心：“我甚至连四维空间都没法想象，更别说五维或者五百万维了”。是不是这些人缺少了某种“真正的”超级数学家所具有的超能力？当然不是。即便是最牛哄哄的数学家也很难想象四维空间，如果可以的话。技巧在于这些数学家发展了一套描述问题的替代方法，而这正是我们刚才所做的：我们用一套代数形式的（而非直观的）算法来表征 $\Delta C$，从而进一步思考怎样让$C$不断减小。那些擅长思考高维空间的人，其实头脑中内建了一个“库”，这个“库”包含了许多类似于刚才描述的这些抽象方法。这些方法也许不像我们所熟知的三维空间那样简单直观，不过一旦你在头脑中也建立了这个“库”，你就可以驾轻就熟地“想象”高维空间了。这里我就不再深入讨论下去了，如果你对于数学家们怎样想象高维空间感兴趣的话，你可能会喜欢读这篇讨论。虽然其中讨论到的一些方法非常复杂，但主要的方法还是比较直观，也可以被大家掌握的。 1.8使用神经网络识别手写数字好了，让我们使用随机梯度下降算法和MNIST训练数据来写一个能够学习识别手写数字的程序。首先我们需要获得MNIST数据。如果你是git的使用者，你可以通过克隆这本书的源代码库来获得这些数据,1git clone https://github.com/mnielsen/neural-networks-and-deep-learning.git 如果你不使用git，你可以通过这里下载所需的数据和源代码。顺便说一下，早些时候我在描述MNIST数据时，我说过它被分成了两份，其中60000幅图片用于训练，另外10000幅用于测试。那是MNIST官方的陈述。事实上，我们将要使用的分法会有一点区别。用于测试的数据我们不会改动，但是60000幅用于训练的图片将被分成两部分：其中一份包括50000幅图片，将用于训练我们的神经网络，剩下的10000幅图片将作为验证集（validation set）。虽然我们在这一章不会用这个验证集，但是在这本书之后的部分我们会发现验证集对确定怎么设置神经网络的一些超参数(hyper－parameters)很有用，比如学习速率等，这些参数没有在我们的学习算法中直接选取。尽管验证集不是MNIST数据的原始规范，但是很多人都是用这种方式使用MNIST，验证集的使用在神经网络中非常普遍。从现在开始，当我说到“MNIST训练数据集”时，我指的是我们分出来的50000幅图片，而不是原来的60000幅图片集。除去MNIST数据，我们还需要一个叫Numpy的Python函数库用于做快速线性代数运算。如果你还没有安装Numpy，你通过pip install numpy安装它。 在给出完整的列表之前，下面让我先解释一下神经网络程序的核心特征。最重要的部分就是一个叫Network的类（class），它被用来表示一个神经网络。下面是用于初始化Network对象的代码:12345678class Network(object): def __init__(self, sizes): self.num_layers = len(sizes) self.sizes = sizes self.biases = [np.random.randn(y, 1) for y in sizes[1:]] self.weights = [np.random.randn(y, x) for x, y in zip(sizes[:-1], sizes[1:])] 在这段代码中，列表sizes包含在对应层的神经元的个数。因此，比如说，如果我们想要构造一个Network对象，其中第一层有2个神经元，第二层有3个神经元，最后一层只有1个神经元，我们可以通过下面的代码做到些：1net = Network([2, 3, 1]) Network对象中所有的偏移（biases）和权重（weights）都通过Numpy中的np.random.randn函数产生标准正态分布的随机数进行初始化。这个随机的初始化给了随机梯度下降算法一个起始点。在随后的章节中我们会找到更好的初始化的方法，但是现在会用这个方法。注意到Network初始化的代码假设了第一层神经元为输入层，并且没有对那些神经元设置偏移量，因为只有在计算之后层的输出时才用到偏移量。 同时也要注意到，偏移量和权重系数被储存为Numpy矩阵的列表。因此，比如说net.weights[1] 就是一个Numpy矩阵，它储存着连接第2层和第3层神经元的权重系数。（注意不是第1层和第2层，因为python列表的索引指标是从0开始的。）因为net.weights[1]比较冗长，让我们用w表示这个矩阵。矩阵元$w_{jk}$就是连接第2层中第$k$个神经元和第3层中第$j$个神经元的权重系数。索引指标$j$和$k$这样的排序是不是看上去有点奇怪，交换$j$和$k$的顺序是不是看上去更合理？这样排序的最大的好处就是第三层的神经元的激活向量（vector of activations）可以直接写成： a'=\sigma (wa+b) \tag{22}\label{(22)}这个公式描述的过程有点多，因此让我们一点一点地来解开。$a$是第2层神经元的激活向量（vector of activations）。为了得到$a’$，我们先将$a$乘以权重矩阵$w$，然后加上偏移向量$b$，最后我们对向量$wa +b$中的每一个元使用函数$\sigma$。（这叫函数$\sigma$的向量化（vectorizing）。）很容验证，在计算sigmoid神经元的输出结果时，公式$\color{lime}{\eqref{(22)}}$给出的结果会和我们之前用公式$\color{lime}{\eqref{(4)}}$所说的方式给出的结果是一样的。练习将公式$\color{lime}{\eqref{(22)}}$写成向量元素的形式，验证在算sigmoid神经元的输出时，它给出的结果和公式$\color{lime}{\eqref{(4)}}$的结果是一样的。 有了这些在心中，很容易写一段程序用于计算一个Network 对象的输出结果。我们从定义sigmoid函数开始：12def sigmoid(z): return 1.0/(1.0+np.exp(-z)) 注意到，当输入量z是一个向量或者Numpy数组，Numpy自动地对向量的每一个元运用sigmoid函数。 然后我们对Network 类加一个feedforward方法。当一个输入量a 给了network，这个方法就给出对应的输出。这个公式所做的就是将公式$\color{lime}{\eqref{(22)}}$运用到每一层123456def feedforward(self, a): """Return the output of the network if "a" is input.""" """第一层输入，第n层输出""" for b, w in zip(self.biases, self.weights): a = sigmoid(np.dot(w, a)+b) return a 当然，我们想让Network对象做的最主要的事情是学习。为了达到这个目的，我们要给它们一个SGD方法，用这个方法实现随机梯度下降算法。下面是代码。有几处地方有一点难以理解，但是我们会在给出代码后加以讲解。123456789101112131415161718192021222324def SGD(self, training_data, epochs, mini_batch_size, eta, test_data=None): """Train the neural network using mini-batch stochastic gradient descent. The "training_data" is a list of tuples "(x, y)" representing the training inputs and the desired outputs. http://tensorfly.cn/home The other non-optional parameters are self-explanatory. If "test_data" is provided then the network will be evaluated against the test data after each epoch, and partial progress printed out. This is useful for tracking progress, but slows things down substantially.""" if test_data: n_test = len(test_data) n = len(training_data) for j in xrange(epochs): random.shuffle(training_data) mini_batches = [ training_data[k:k+mini_batch_size] for k in xrange(0, n, mini_batch_size)] for mini_batch in mini_batches: self.update_mini_batch(mini_batch, eta) if test_data: print "Epoch &#123;0&#125;: &#123;1&#125; / &#123;2&#125;".format( j, self.evaluate(test_data), n_test) else: print "Epoch &#123;0&#125; complete".format(j) training_data是一个由(x, y)类型元组组成的列表，其中x表示训练数据的输入，y为对应的输出。变量epochs和mini_batch_size正如你所预期的一样,分别是训练的代数和取样时最小组的大小。eta是学习的速率，$\eta$。如果可选参量test_data被提供了，程序在每一个训练“代”（epoch）结束之后都会评估神经网络的表现，然后输出部分进展。这对跟踪进展有用，但是会大大减慢速度。2018-09-13 21:42:47这段代码按照下面的方式运行。在每一代（epoch），程序首先随机地打乱训练数据的顺序，然后将数据分成合适大小的mini_batch。这个很容，就是随机从训练数据中抽样。接下来，对每一个epochs，我们使用一次梯度下降算法。这个通过self.update_mini_batch(mini_batch, eta)所对应的程序代码实现，这段代码会利用mini_batch中的训练数据，通过一个梯度下降的循环来更新神经网络的权重系数和偏移量。下面是update_mini_batch方法的源代码：123456789101112131415def update_mini_batch(self, mini_batch, eta): """Update the network's weights and biases by applying gradient descent using backpropagation to a single mini batch. The "mini_batch" is a list of tuples "(x, y)", and "eta" is the learning rate.""" nabla_b = [np.zeros(b.shape) for b in self.biases] nabla_w = [np.zeros(w.shape) for w in self.weights] for x, y in mini_batch: delta_nabla_b, delta_nabla_w = self.backprop(x, y) nabla_b = [nb+dnb for nb, dnb in zip(nabla_b, delta_nabla_b)] nabla_w = [nw+dnw for nw, dnw in zip(nabla_w, delta_nabla_w)] self.weights = [w-(eta/len(mini_batch))*nw for w, nw in zip(self.weights, nabla_w)] self.biases = [b-(eta/len(mini_batch))*nb for b, nb in zip(self.biases, nabla_b)] 大部分工作都是下面这一行做的：1delta_nabla_b, delta_nabla_w = self.backprop(x, y) 这个牵涉到一个叫逆传播（backpropagation）的算法，这个算法可以快速计算代价函数（cost function）的梯度。因此update_mini_batch 所作的仅仅就是对 mini_batch中每一个训练数据样本计算这些梯度，然后更新self.weights和self.biases。 现在我不会展示出self.backprop的源代码。我们会在下一章学习逆传播是怎么工作的，以及self.backprop的源代码。现在，就假设它如上面所说的方式工作，返回每一个训练数据样本x所对应成本的正确梯度。 让我们看一下整个程序，包括之前忽略了的说明文档。除了self.backprop，整个程序是无需解释的－－所有重要的事情是在self.SGD和self.update_mini_batch中做的，我们之前已经讨论过了。self.backprop方法在计算梯度的时候还要用到一些额外的函数，包括sigmoid_prime，用来计算$\sigma$函数的导数，和self.cost_derivative。后面这个我暂时不会在这里描述。只要看一看这些方法的代码或者说明文档，你就可以了解它们的主要意思（甚至细节）。我们将在下一章详细研究它们。注意到这个程序看上去很长，但是大部分都是说明文档，让这个程序更容易理解。实际上，整个程序只有74行非空白、非注释代码。所有的代码可以在GitHub上找到。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141"""network.py~~~~~~~~~~A module to implement the stochastic gradient descent learningalgorithm for a feedforward neural network. Gradients are calculatedusing backpropagation. Note that I have focused on making the codesimple, easily readable, and easily modifiable. It is not optimized,and omits many desirable features."""#### Libraries# Standard libraryimport random# Third-party librariesimport numpy as npclass Network(object): def __init__(self, sizes): """The list ``sizes`` contains the number of neurons in the respective layers of the network. For example, if the list was [2, 3, 1] then it would be a three-layer network, with the first layer containing 2 neurons, the second layer 3 neurons, and the third layer 1 neuron. The biases and weights for the network are initialized randomly, using a Gaussian distribution with mean 0, and variance 1. Note that the first layer is assumed to be an input layer, and by convention we won't set any biases for those neurons, since biases are only ever used in computing the outputs from later layers.""" self.num_layers = len(sizes) self.sizes = sizes self.biases = [np.random.randn(y, 1) for y in sizes[1:]] self.weights = [np.random.randn(y, x) for x, y in zip(sizes[:-1], sizes[1:])] def feedforward(self, a): """Return the output of the network if ``a`` is input.""" for b, w in zip(self.biases, self.weights): a = sigmoid(np.dot(w, a)+b) return a def SGD(self, training_data, epochs, mini_batch_size, eta, test_data=None): """Train the neural network using mini-batch stochastic gradient descent. The ``training_data`` is a list of tuples ``(x, y)`` representing the training inputs and the desired outputs. The other non-optional parameters are self-explanatory. If ``test_data`` is provided then the network will be evaluated against the test data after each epoch, and partial progress printed out. This is useful for tracking progress, but slows things down substantially.""" if test_data: n_test = len(test_data) n = len(training_data) for j in xrange(epochs): random.shuffle(training_data) mini_batches = [ training_data[k:k+mini_batch_size] for k in xrange(0, n, mini_batch_size)] for mini_batch in mini_batches: self.update_mini_batch(mini_batch, eta) if test_data: print "Epoch &#123;0&#125;: &#123;1&#125; / &#123;2&#125;".format( j, self.evaluate(test_data), n_test) else: print "Epoch &#123;0&#125; complete".format(j) def update_mini_batch(self, mini_batch, eta): """Update the network's weights and biases by applying gradient descent using backpropagation to a single mini batch. The ``mini_batch`` is a list of tuples ``(x, y)``, and ``eta`` is the learning rate.""" nabla_b = [np.zeros(b.shape) for b in self.biases] nabla_w = [np.zeros(w.shape) for w in self.weights] for x, y in mini_batch: delta_nabla_b, delta_nabla_w = self.backprop(x, y) nabla_b = [nb+dnb for nb, dnb in zip(nabla_b, delta_nabla_b)] nabla_w = [nw+dnw for nw, dnw in zip(nabla_w, delta_nabla_w)] self.weights = [w-(eta/len(mini_batch))*nw for w, nw in zip(self.weights, nabla_w)] self.biases = [b-(eta/len(mini_batch))*nb for b, nb in zip(self.biases, nabla_b)] def backprop(self, x, y): """Return a tuple ``(nabla_b, nabla_w)`` representing the gradient for the cost function C_x. ``nabla_b`` and ``nabla_w`` are layer-by-layer lists of numpy arrays, similar to ``self.biases`` and ``self.weights``.""" nabla_b = [np.zeros(b.shape) for b in self.biases] nabla_w = [np.zeros(w.shape) for w in self.weights] # feedforward activation = x activations = [x] # list to store all the activations, layer by layer zs = [] # list to store all the z vectors, layer by layer for b, w in zip(self.biases, self.weights): z = np.dot(w, activation)+b zs.append(z) activation = sigmoid(z) activations.append(activation) # backward pass delta = self.cost_derivative(activations[-1], y) * \ sigmoid_prime(zs[-1]) nabla_b[-1] = delta nabla_w[-1] = np.dot(delta, activations[-2].transpose()) # Note that the variable l in the loop below is used a little # differently to the notation in Chapter 2 of the book. Here, # l = 1 means the last layer of neurons, l = 2 is the # second-last layer, and so on. It's a renumbering of the # scheme in the book, used here to take advantage of the fact # that Python can use negative indices in lists. for l in xrange(2, self.num_layers): z = zs[-l] sp = sigmoid_prime(z) delta = np.dot(self.weights[-l+1].transpose(), delta) * sp nabla_b[-l] = delta nabla_w[-l] = np.dot(delta, activations[-l-1].transpose()) return (nabla_b, nabla_w) def evaluate(self, test_data): """Return the number of test inputs for which the neural network outputs the correct result. Note that the neural network's output is assumed to be the index of whichever neuron in the final layer has the highest activation.""" test_results = [(np.argmax(self.feedforward(x)), y) for (x, y) in test_data] return sum(int(x == y) for (x, y) in test_results) def cost_derivative(self, output_activations, y): """Return the vector of partial derivatives \partial C_x / \partial a for the output activations.""" return (output_activations-y)#### Miscellaneous functionsdef sigmoid(z): """The sigmoid function.""" return 1.0/(1.0+np.exp(-z))def sigmoid_prime(z): """Derivative of the sigmoid function.""" return sigmoid(z)*(1-sigmoid(z)) 这个程序识别手写数字的效果怎么样呢? 好，让我们从加载MNIST数据开始。我将用下面这个小脚本mnist_loader.py来做这件事, 我们将在python shell中运行下面的指令，123&gt;&gt;&gt; import mnist_loader&gt;&gt;&gt; training_data, validation_data, test_data = \... mnist_loader.load_data_wrapper() 当然，这也可以通过一个独立的python程序来完成，不过如果你一直在跟着这个教程走，在python shell中完成应该是最简单的。加载完MNIST数据后，我们将要建立一个有$30$个隐藏神经元的Network。这件事是在我们导入上面的Python程序之后去做的，对应的变量我们称其为network,12&gt;&gt;&gt; import network&gt;&gt;&gt; net = network.Network([784, 30, 10]) 最终，我们将用随机梯度下降法，由MNIST training_data完成学习过程。该过程将历经30代（epoch），其每“组”（mini-batch）的样本数为10，学习率（learning rate）为 $\eta = 3.0$,1&gt;&gt;&gt; net.SGD(training_data, 30, 10, 3.0, test_data=test_data) 注意：如果你在一边在读教程一边在跑程序，你会发现这些程序的执行需要花点时间 —— 对于一般的主机（2015年左右），大概需要几分钟。我建议你一边运行，一边继续阅读，并且周期性地查看代码的输出结果。如果你时间比较赶，你可以通过减少学习的epoch数目，减少隐藏神经元的数目，或者只用部分训练数据等方法来加速程序的运行过程。注意用于生产环境的代码（production code）会远远快于现在的速度：这里的python脚本是用来帮助你理解神经网络是怎样工作的，而并非以高效运行为目标的代码！当然，一旦我们将神经网络训练好，我们就可以在几乎任何计算平台上运行得飞快。例如，一旦我们通过神经网络的学习过程获得了一组很好的权重和偏移，我们就可以将其非常容易地移植为网页浏览器的javascript版本，或者是移动设备的原生应用版本。不管怎样，下面是训练神经网络过程的一组结果。这组结果显示了经历每一代训练后，可以正确辨认出来的测试图片的个数。正如你所看到的，经历过第一代训练后，其准确率已经达到10,000张图片中识别出9,129张图片，并且这个数字在不断增加， 参考资料原文:http://neuralnetworksanddeeplearning.com/chap1.html]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DEBUG常用功能]]></title>
    <url>%2F2018%2F02%2F12%2FDEBUG%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[window 10中DEBUG的安装以及DEBUG调试中一些常用的命令 1.安装window 10中好像已经没有了Debug的调试工具，需要下载另外的软件 下载安装DOSBox.百度云下载地址：DOSBOX下载后先安装DOSBox0.74-win32-installer.exe然后找到文件dos-box0.74.conf(C:\Users\username\AppData\Local\DOSBox)添加两行12MOUNT C E:\DEBUG # 将目录E:\DEBUG挂载为DOSBOX下的C: set PATH=$PATH$;E:\DEBUG # 将E:\DEBUG写入环境变量PATH中 并将下载的MASM.exe,LINK.exe,debug.exe三个文件放入目录E:\DEBUG打开软件，输入c:就可以使用debug命令了 2.常用命令:R命令：查看改变CPU寄存器的内容D命令：查看内存中的内容E命令：改写内存中的内容U命令：将内存中的机器指令翻译成汇编指令T命令：执行一条机器指令A命令：以汇编指令的格式在内存中写入一条机器指令Q命令：退出DEBUG调试2018-02-12 21:50:06 3.命令具体使用实例3.1R命令：R命令：查看改变CPU寄存器的内容12-r ;显示寄存器的值-r reg ;改变寄存器reg的值 3.2D命令：D命令：查看内存中的内容默认显示128字节的内容123-d ;默认地址-d 段地址:偏移地址 ;指定地址-d 段地址:偏1 偏2 ;两个地址间的内容 3.3E命令：E命令：改写内存中的内容12-e 起始地址 数据 数据 ... -e 起始地址 3.4U命令：U命令：将内存中的机器指令翻译成汇编指令与D命令有些类似 3.5T命令：T命令：执行内存中的一条机器指令指令位置由cs:ip确定 3.6A命令：A命令：以汇编指令的格式在内存中写入一条机器指令2018-02-13 22:41:40]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>DEBUG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单了解汇编]]></title>
    <url>%2F2018%2F02%2F11%2F%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E6%B1%87%E7%BC%96%2F</url>
    <content type="text"><![CDATA[一些汇编的基础知识 1.汇编是什么汇编语言的主体是汇编指令，汇编指令是由机器指令发展而来，例如：操作：将寄存器bx的内容送到ax机器指令：101100000000000000000011记起来太过于复杂，从而有了替代它的汇编指令：mov ax,bx方便记忆，也符合人们的逻辑思维程序员们编写汇编指令，在通过编译器编译成机器指令，然后就可以在计算机中运行了（如今的大部分高级语言是通过编译器，将高级语言转换成汇编语言，在编译成机器语言在电脑中运行）不管什么语言，都要转换成机器语言在电脑中运行，汇编语言和高级语言都是人们为了简化程序制作过程而已 2.计算机的总线从逻辑上总线分为三类（8086）数据总线：传送数据，总线宽度决定一次读取数据多少（16）地址总线：指定地址，总线宽度决定寻址能力（20）控制总线：控制读写 3.存储器RAM：程序和数据都要加载到RAM即内存中，才能通过CPU运行，可读可写ROM：一些芯片的主要参数，及操作指令，芯片出厂时已经固定，仅可读计算机运行时，全部程序和数据都要加载到RAM中通过ROM中的一些必要信息，CPU才能对外设进行操作]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>x8086</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git使用中的一些问题]]></title>
    <url>%2F2018%2F01%2F22%2FGit%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[总结使用git的过程中遇到的问题 1.配置问题全局配置123$ git config --list 查看当前用户信息$ git config --global user.name &quot;username&quot; 配置用户名$ git config --global user.email emailname@example.com 配置邮箱 项目配置(进入项目目录)123$ cat .git/config 项目配置信息$ git config user.name &quot;username&quot; 配置用户名$ git config user.email emailname@example.com 配置邮箱 全局的配置就是加上--global项目未设置的配置默认使用全局配置 2.密钥问题123$ cd ~/.ssh 查看是否存在密钥$ ssh-keygen -t rsa -C &quot;emailname@example.com&quot; 生成密钥$ ssh -T git@github.com 测试是否配置成功 生成密钥过程中回车三次，是密码为空，不然每次push都要输入密码生成密钥后主要有两个文件~/.ssh/id_rsa私钥进行处理后的一些内容~/.ssh/id_rsa.pub公钥进行处理后的内容，提交到服务器(github或coding)的内容~/.ssh/known_hosts这个文件可能会有，是ssh对服务短的一些记录 参考资料1,https://www.cnblogs.com/hustskyking/p/problems-in-git-when-ssh.html2,http://blog.csdn.net/u013626215/article/details/51508085]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Altium快捷键]]></title>
    <url>%2F2017%2F12%2F31%2FAltium%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[快捷键使用ctrl+shft+T(top)：上对齐ctrl+shft+B(bottom):下对齐ctrl+shft+L(left):左对齐ctrl+shft+T(right):右对齐ctrl+shft+H(horizonta):水平方向上等距ctrl+shft+V(vertical):竖直方向上的等距]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>Altium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位运算的妙用之二进制1的个数]]></title>
    <url>%2F2017%2F12%2F30%2F%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%A6%99%E7%94%A8%E4%B9%8B%E4%BA%8C%E8%BF%9B%E5%88%B61%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：求出一个正整数转换成二进制形式中数字”1”的个数如：int 型数值为 80转化成二进制形式：80 = 00000000 00000000 00000000 01010000因此 1 的个数为 2 1.普通解法一位一位判断123456789int bitCount1(int n) &#123; int count = 0; while (n != 0) &#123; if (n &amp; 0x01 == 1) count++; n = n &gt;&gt; 1; &#125; return count;&#125; 2.大神的解法算法分析看参考12345678int bitCount2(int n) &#123; n = n - ((n &gt;&gt; 1) &amp; 0x55555555);//n = (n &amp; 0x55555555) + ((n &gt;&gt; 1) &amp; 0x55555555); n = (n &amp; 0x33333333) + ((n &gt;&gt; 2) &amp; 0x33333333); n = (n &amp; 0x0f0f0f0f) + ((n &gt;&gt; 4) &amp; 0x0f0f0f0f); n = n + (n &gt;&gt; 8); //n = (n &amp; 0x00ff00ff) + ((n &gt;&gt; 8) &amp; 0x00ff00ff); n = n + (n &gt;&gt; 16); //n = (n &amp; 0x0000ffff) + ((n &gt;&gt; 16) &amp; 0x0000ffff); return n &amp; 0x0000003f; //return n;&#125; 参考文章1.https://www.jianshu.com/p/25c75149e7a22017-12-30 16:32:32]]></content>
      <categories>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python遇到的错误]]></title>
    <url>%2F2017%2F12%2F26%2Fpython%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[python使用在中遇到的错误 python ImportError: DLL load failed: %1 不是有效的 Win32 应用程序解决方法：去下载与你所安装的Python版本对应的pywin32并安装下载链接：https://sourceforge.net/projects/pywin32/files/pywin32/对应版本和位数Python 2.7.13 (v2.7.13:a06454b1afa1, Dec 17 2016, 20:42:59) [MSC v.1500 32 bit (Intel)] on win32Type “help”, “copyright”, “credits” or “license” for more information.还有一种可能是导入的模块是64位的，而你的python是32位的参考: http://blog.csdn.net/sinat_34615726/article/details/67636949 2017-12-26 15:41:42]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串匹配]]></title>
    <url>%2F2017%2F12%2F21%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[1.BM算法 2.KMP算法 1.BM算法从左到右依次比较s:主串r:模式串1234567891011121314int BM(char *s,int slen,char *r,int rlen)&#123; int i=1,j=1; while(i&lt;=slen-rlen+1)&#123; while(j&lt;=rlen&amp;&amp;s[i]==r[j])&#123; i++;j++; &#125; if(j&gt;rlen)&#123; return i-j+1; &#125;else&#123; j=1;i++; &#125; &#125; return 0;&#125; 2.KMP算法通过一个next数字当每次发生不匹配的时候模式串不必回到开头12345678910111213141516171819202122232425262728293031int* getnext(char *r, int n) &#123; //next数组求解 int i, j; int *next = (int *)malloc((n + 1) * sizeof(int)); next[0] = n; next[1] = 0; j = 0; i=1; while(i&lt;n)&#123; if (j == 0 || r[i] == r[j]) &#123; ++i; ++j; next[i] = j; &#125; else &#123; j = next[j]; &#125; &#125; return next;&#125;int KMP(char *s,int slen,char *r,int rlen)&#123; int *next=getnext(r,rlen); int i=1,j=1; while(i&lt;=slen&amp;&amp;j&lt;=rlen)&#123; while(j&lt;=rlen&amp;&amp;s[i]==r[j])&#123; i++;j++; &#125; if(j&gt;rlen)&#123; return i-j+1; &#125;else&#123; j=next[j];i++; &#125; &#125; return 0;&#125; 2017-12-21 20:57:49 参考文章1.字符串模式匹配的BM算法2.字符串匹配的KMP算法]]></content>
      <categories>
        <category>算法总结</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime_Text3插入当前时间]]></title>
    <url>%2F2017%2F12%2F21%2Fsublime_Text3%E6%8F%92%E5%85%A5%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[1.创建新snippettool → new snippet 创建一个新的snippet,并保存为”author.sublime-snippet”(最好在该目录(User)下再创建一个MySnippet目录):其内容:123456789101112131415&lt;snippet&gt;&lt;content&gt;&lt;![CDATA[/** * ============================ * @Author: XX * @Version: 1.0 * @DateTime: $&#123;1:alt+t&#125; * ============================ */]]&gt;&lt;/content&gt; &lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --&gt; &lt;tabTrigger&gt;author&lt;/tabTrigger&gt; &lt;!-- Optional: Set a scope to limit where the snippet will trigger --&gt; &lt;!-- &lt;scope&gt;source.python&lt;/scope&gt; --&gt;&lt;/snippet&gt; 2.创建新插件Tools → New Plugin. 创建时间插件,保存在User目录,命名为addCurrentTime.py:其内容为:123456789import sublime, sublime_pluginimport datetimeclass AddCurrentTimeCommand(sublime_plugin.TextCommand): def run(self, edit): self.view.run_command("insert_snippet", &#123; "contents": "%s" % datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S") &#125; ) 3.绑定快捷键Preference → Key Bindings → User.绑定快捷键:12345678[ &#123; &quot;command&quot;: &quot;add_current_time&quot;, &quot;keys&quot;: [ &quot;alt+t&quot; ] &#125;] 其中绑定的命令的名字是由所创建的插件的类名而来AddCurrentTimeCommand—&gt;add_current_time这应该是Sublime创建插件的规则 参考资料1,http://www.cnblogs.com/xiaomingzaixian/p/6984664.html2,http://blog.csdn.net/sshfl_csdn/article/details/46415551]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言文件读写]]></title>
    <url>%2F2017%2F12%2F12%2FC%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%2F</url>
    <content type="text"><![CDATA[C语言文件操作笔记123456FILE *fopen(char *filename,char *type); //打开文件int fclose(FILE *stream); //关闭文件int fgetc(FILE *stream); //读一个字符指针后移int getc(FILE *stream);int fputc(int ch,FILE *stream); //写一个字符指针后移int putc(int ch,FILE *stream); filename指明文件路径type可取的至如下“r” :打开一个已有的文本文，允许读取文件“w” :打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容“a” :打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。“r+”:打开一个文本文件，允许读写文件“w+”:打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件“a+”:打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式:&quot;rb&quot;, &quot;wb&quot;, &quot;ab&quot;, &quot;rb+&quot;, &quot;r+b&quot;, &quot;wb+&quot;, &quot;w+b&quot;, &quot;ab+&quot;, &quot;a+b&quot;2017-12-31 13:58:16]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片头文件解析]]></title>
    <url>%2F2017%2F12%2F12%2F%E5%9B%BE%E7%89%87%E5%A4%B4%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1.PNG图片文件头1.1PNG文件结构PNG图像格式文件由一个8字节的PNG文件标识（file signature）域和3个以上的后续数据块（IHDR、IDAT、IEND等）组成。PNG文件包括8字节文件署名（89 50 4E 47 0D 0A 1A 0A，十六进制），用来识别PNG格式。 十六进制 含义 89 用于检测传输系统是否支持8位的字符编码（8 bit data），用以减少将文本文件被错误的识别成PNG文件的机会，反之亦然。 50 4E 47 PNG每个字母对应的ASCII，让用户可以使用文本编辑器查看时，识别出是PNG文件。 0D 0A DOS风格的换行符（CRLF）。用于DOS-Unix数据的换行符转换。 1A 在DOS命令行下，用于阻止文件显示的文件结束符。 0A Unix风格的换行符（LF）。用于Unix-DOS换行符的转换。 1.2PNG数据块（chunk）PNG定义了两种类型的数据块，一种是称为关键数据块(critical chunk)，这是标准的数据块，另一种叫做辅助数据块(ancillary chunks)，这是可选的数据块。关键数据块定义了4个标准数据块，每个PNG文件都必须包含它们，PNG读写软件也都必须要支持这些数据块。虽然PNG文件规范没有要求PNG编译码器对可选数据块进行编码和译码，但规范提倡支持可选数据块。 下表就是PNG中数据块的类别，其中，关键数据块部分我们使用红色背景加以区分。 PNG文件格式中的数据块数据块符号数据块名称多数据块可选否位置限制IHDR文件头数据块否否第一块cHRM基色和白色点数据块否是在PLTE和IDAT之前gAMA图像γ数据块否是在PLTE和IDAT之前sBIT样本有效位数据块否是在PLTE和IDAT之前PLTE调色板数据块否是在IDAT之前bKGD背景颜色数据块否是在PLTE之后IDAT之前hIST图像直方图数据块否是在PLTE之后IDAT之前tRNS图像透明数据块否是在PLTE之后IDAT之前oFFs(专用公共数据块)否是在IDAT之前pHYs物理像素尺寸数据块否是在IDAT之前sCAL(专用公共数据块)否是在IDAT之前IDAT图像数据块是否与其他IDAT连续tIME图像最后修改时间数据块否是无限制tEXt文本信息数据块是是无限制zTXt压缩文本数据块是是无限制fRAc(专用公共数据块)是是无限制gIFg(专用公共数据块)是是无限制gIFt(专用公共数据块)是是无限制gIFx(专用公共数据块)是是无限制IEND图像结束数据否否最后一个数据块&lt;—2018-03-29 18:44:39—&gt;]]></content>
      <categories>
        <category>文件</category>
      </categories>
      <tags>
        <tag>文件头</tag>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS自带python2.6升级到2.7]]></title>
    <url>%2F2017%2F09%2F12%2FCentOS%E8%87%AA%E5%B8%A6python2-6%E5%8D%87%E7%BA%A7%E5%88%B02-7%2F</url>
    <content type="text"><![CDATA[下载python2.71[root@host ~]# wget http://python.org/ftp/python/2.7.3/Python-2.7.3.tar.bz2 解压并更改目录12[root@host ~]# tar -jxvf Python-2.7.3.tar.bz2[root@host ~]# cd Python-2.7.3 编译安装12345[root@host Python-2.7.3]# ./configure[root@host Python-2.7.3]# make all[root@host Python-2.7.3]# make install[root@host Python-2.7.3]# make clean[root@host Python-2.7.3]# make distclean 安装需要gcc(如果系统没有gcc需要自己安装)1[root@host Python-2.7.3]# yum install -y gcc 查看版本信息1234[root@host ~]# /usr/local/bin/python2.7 -VPython 2.7.3[root@host ~]# python -VPython 2.6.6 python2.7已经安装,但系统的python还是2.6 建立软连接，使系统默认的python指向python2.712rm /usr/bin/python /usr/bin/python2.6ln -s /usr/local/bin/python2.7 /usr/bin/python 但yum命令依赖python2.6.6，需要更改一些配置文件12su root ##切换到root vi /usr/bin/yum ##打开文件 /usr/bin/python ##删除此行/usr/bin/python2.6.6 ##改为此行更改需要管理员权限 参考:http://blog.csdn.net/jcjc918/article/details/11022345]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VC6聊天室程序设计]]></title>
    <url>%2F2017%2F09%2F11%2FVC6%E8%81%8A%E5%A4%A9%E5%AE%A4%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[了解了C语言多线程的实例和简单的TCP通信，来编写一个简单的聊天室曾经java实现的聊天室程序在这里客户端程序客户端需要两个线程，主线程接受用户输入并发送到服务器另一个线程监听服务器发来的消息，显示在屏幕上123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include "winsock2.h"#include "stdio.h"#define SERVER_IP "10.80.167.248"#define SERVER_PORP 8884//blog:zfblog.xyz//author:FreyDWORD WINAPI ThreadFun(LPVOID pM) &#123; SOCKET sockClient=*(SOCKET *)pM; char recvInfo[100]; while(1) &#123; if(recv(sockClient,recvInfo,100,0)&gt;0) &#123; printf("%s",recvInfo); &#125; &#125; return 0;&#125;void main()&#123; //加载套接字库 WORD wVersionRequested; WSADATA wsaData; int err; wVersionRequested = MAKEWORD( 1, 1 ); //版本好为1.1 err = WSAStartup( wVersionRequested, &amp;wsaData ); if ( err != 0 ) &#123; return; &#125; if ( LOBYTE( wsaData.wVersion ) != 1 || HIBYTE( wsaData.wVersion ) != 1 ) &#123; WSACleanup( ); return; &#125; SOCKET sockClient=socket(AF_INET,SOCK_STREAM,0); //SOCK_STREAM参数设置为TCP连接 SOCKADDR_IN addrServer; //服务器地址结构 addrServer.sin_addr.S_un.S_addr=inet_addr(SERVER_IP); //服务器地址 addrServer.sin_port=htons(SERVER_PORP); //服务器端口号 addrServer.sin_family=AF_INET; //与服务器端建立连接，进行通信 char name[100]; printf("请输入姓名:"); scanf("%s",name); int connReult=connect(sockClient,(SOCKADDR*)&amp;addrServer,sizeof(SOCKADDR)); if(connReult!=WSAEADDRNOTAVAIL) //访问成功 &#123; CreateThread(NULL, 0, ThreadFun, (void *)&amp;sockClient, 0, NULL); printf("连接成功\n"); //成功建立连接后向服务器端发送数据，结果将显示在服务器端上 char sendInfo[100]; sprintf(sendInfo,name); send(sockClient,sendInfo,strlen(sendInfo)+1,0); //接收来自服务器端发送来的信息 //char recvInfo[100]; //recv(sockClient,recvInfo,100,0); //printf("%s\n",recvInfo); while(1) &#123; scanf("%s",sendInfo); send(sockClient,sendInfo,strlen(sendInfo)+1,0); &#125; &#125; else &#123; int errCode=WSAGetLastError(); printf("the errcode is:%d\n",errCode); &#125; closesocket(sockClient); WSACleanup();&#125; 服务器程序用一个链表来存储用户的套接字和姓名主线程监听用户的连接，每当有新用户连接，将其信息加入链表，并传入第二个线程第二个线程接受客户端发来的信息，并将信息传入第三个线程第三个线程从链表中读取用户套接字，将接到的信息转发给所有在线用户123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include "winsock2.h"#include "stdio.h"#include &lt;windows.h&gt;//blog:zfblog.xyz//author:Frey#define SERVER_PORP 8884struct client_info&#123; SOCKET sockConn; char name[100]; client_info *next;&#125;;//存放每一个用户的信息client_info * C_info_head;DWORD WINAPI Threadmes(LPVOID pM)&#123; char sendInfo[100]; sprintf(sendInfo,(char *)pM); for(int i=0;i&lt;=c_info_num;i++)&#123; SOCKET sockConn=C_info[i].sockConn; //if(C_info[i].num!=-1)&#123; send(sockConn,sendInfo,strlen(sendInfo)+1,0); //&#125; &#125; return 0;&#125;//将某条消息群发给所有客户端void sendmessage(char *message)&#123; CreateThread(NULL, 0, Threadmes, (void *)message, 0, NULL);&#125;//接收每个用户的信息DWORD WINAPI ThreadFun(LPVOID pM) &#123; client_info c_info = *(client_info *)pM; SOCKET sockConn=c_info.sockConn; char sendInfo[100]; //inet_ntoa将结构转换为十进制的IP地址字符串 //sprintf(sendInfo,"welcome %s to this Server!",inet_ntoa(addrClient.sin_addr)); //成功建立连接后向客户端发送数据，结果将显示在客户端上 //send(sockConn,sendInfo,strlen(sendInfo)+1,0); //从客户端接收数据，结果显示在服务器上 char recvInfo[100]; recv(sockConn,recvInfo,100,0); sprintf(c_info.name,recvInfo); printf("欢迎%s进入聊天室\n",recvInfo); sprintf(sendInfo,"欢迎%s进入聊天室\n",recvInfo); sendmessage(sendInfo); while(1) &#123; if(recv(sockConn,recvInfo,100,0)&lt;0) break; printf("[%s]:%s\n",c_info.name,recvInfo); sprintf(sendInfo,"[%s]:%s\n",c_info.name,recvInfo); sendmessage(sendInfo); &#125; //将本次建立连接中得到套接字关闭 closesocket(sockConn); return 0;&#125;void main()&#123; //加载套接字（winsock）库，加载这段代码拷贝于MSDN中WSAStartup的介绍 WORD wVersionRequested; WSADATA wsaData; int err; wVersionRequested = MAKEWORD( 1, 1 ); //版本号为1.1 err = WSAStartup( wVersionRequested, &amp;wsaData ); if ( err != 0 ) &#123; return; &#125; if ( LOBYTE( wsaData.wVersion ) != 1 || HIBYTE( wsaData.wVersion ) != 1 ) &#123; WSACleanup( ); return; &#125; //消息存储及发送 //---------------------------------------------------- //创建套接字 SOCKET sockServer=socket(AF_INET,SOCK_STREAM,0); //SOCK_STREAM参数设置为TCP连接 SOCKADDR_IN addrServer; //设置服务器端套接字的相关属性 addrServer.sin_addr.S_un.S_addr=htonl(INADDR_ANY); //设置IP addrServer.sin_family=AF_INET; addrServer.sin_port=htons(SERVER_PORP); //设置端口号 //将套接字绑定到本地地址和指定端口上 bind(sockServer,(SOCKADDR*)&amp;addrServer,sizeof(SOCKADDR)); //将套接字设置为监听模式，并将最大请求连接数设置成5，超过此数的请求全部作废 listen(sockServer,5); SOCKADDR_IN addrClient; //用来接收客户端的设置，包括IP和端口 int len=sizeof(SOCKADDR); while(1) //不断监听 &#123; //得到创建连接后的一个新的套接字，用来和客户端进行沟通，原套接字继续监听客户的连接请求 SOCKET sockConn=accept(sockServer,(SOCKADDR*)&amp;addrClient,&amp;len); if(sockConn!=INVALID_SOCKET) //创建成功 &#123; c_info_num++; C_info[c_info_num].num=c_info_num; C_info[c_info_num].sockConn=sockConn; CreateThread(NULL, 0, ThreadFun, (void *)&amp;C_info[c_info_num], 0, NULL); &#125; else &#123; int errCode=WSAGetLastError(); printf("the errcode is:%d\n",errCode); &#125; &#125; //如果本程序不是死循环，那么在此处还应添加以下代码： closesocket(sockServer); //对一直处于监听状态的套接字进行关闭 WSACleanup(); //终止对winsocket库的使用&#125; 未完成的问题用户离线时出现问题 全部代码:https://github.com/summerIwinter]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>TCP</tag>
        <tag>聊天室</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C实现简单TCP通信]]></title>
    <url>%2F2017%2F09%2F05%2FC%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95TCP%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[在VC6++下编程代码用到了其他的lib库,需要添加工程—&gt;设置—&gt;Link—&gt;library modules添加ws2_32.lib(与其他lib用空格隔开) 服务器端代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include"winsock2.h"#include "stdio.h"#define SERVER_PORP 8884//服务器端口号void main()&#123; //加载套接字（winsock）库， //加载这段代码拷贝于MSDN中WSAStartup的介绍 WORD wVersionRequested; WSADATA wsaData; int err; wVersionRequested = MAKEWORD( 1, 1 ); //版本号为1.1 err = WSAStartup( wVersionRequested, &amp;wsaData ); if ( err != 0 ) &#123; return; &#125; if ( LOBYTE( wsaData.wVersion ) != 1 || HIBYTE( wsaData.wVersion ) != 1 ) &#123; WSACleanup( ); return; &#125; //创建套接字 SOCKET sockServer=socket(AF_INET,SOCK_STREAM,0); //AF_INET指协议簇 //SOCK_STREAM参数设置为TCP连接 SOCKADDR_IN addrServer; //设置服务器端套接字的相关属性 addrServer.sin_addr.S_un.S_addr=htonl(INADDR_ANY); //设置IP addrServer.sin_family=AF_INET; addrServer.sin_port=htons(SERVER_PORP); //设置端口号 //将套接字绑定到本地地址和指定端口上 bind(sockServer,(SOCKADDR*)&amp;addrServer,sizeof(SOCKADDR)); //将套接字设置为监听模式，并将最大请求连接数设置成5，超过此数的请求全部作废 listen(sockServer,5); SOCKADDR_IN addrClient; //用来接收客户端的设置，包括IP和端口 int len=sizeof(SOCKADDR); while(1) //不断监听 &#123; //得到创建连接后的一个新的套接字，用来和客户端进行沟通，原套接字继续监听客户的连接请求 SOCKET sockConn=accept(sockServer,(SOCKADDR*)&amp;addrClient,&amp;len); if(sockConn!=INVALID_SOCKET) //创建成功 &#123; char sendInfo[100]; //inet_ntoa将结构转换为十进制的IP地址字符串 sprintf(sendInfo,"welcome %s to this Server!",inet_ntoa(addrClient.sin_addr)); //成功建立连接后向客户端发送数据，结果将显示在客户端上 send(sockConn,sendInfo,strlen(sendInfo)+1,0); //从客户端接收数据，结果显示在服务器上 char recvInfo[100]; recv(sockConn,recvInfo,100,0); printf("%s\n",recvInfo); while(1) &#123; if(recv(sockConn,recvInfo,100,0)&lt;0) break; //客户端断开recv返回负值 printf("%s\n",recvInfo); sprintf(sendInfo,recvInfo); send(sockConn,sendInfo,strlen(sendInfo)+1,0); sprintf(sendInfo,"\nsever receive this text!\n"); send(sockConn,sendInfo,strlen(sendInfo)+1,0); &#125; //将本次建立连接中得到套接字关闭 closesocket(sockConn); &#125; else &#123; int errCode=WSAGetLastError(); printf("the errcode is:%d\n",errCode); &#125; &#125; //如果本程序不是死循环，那么在此处还应添加以下代码： closesocket(sockServer); //对一直处于监听状态的套接字进行关闭 WSACleanup(); //终止对winsocket库的使用&#125; 客户端代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include "winsock2.h"#include "stdio.h"#define SERVER_IP "127.0.0.1" //服务器IP地址#define SERVER_PORP 8884 //服务器端口号void main()&#123; //加载套接字库 WORD wVersionRequested; WSADATA wsaData; int err; wVersionRequested = MAKEWORD( 1, 1 ); //版本好为1.1 err = WSAStartup( wVersionRequested, &amp;wsaData ); if ( err != 0 ) &#123; return; &#125; if ( LOBYTE( wsaData.wVersion ) != 1 || HIBYTE( wsaData.wVersion ) != 1 ) &#123; WSACleanup( ); return; &#125; SOCKET sockClient=socket(AF_INET,SOCK_STREAM,0); //SOCK_STREAM参数设置为TCP连接 SOCKADDR_IN addrServer; //服务器地址结构 addrServer.sin_addr.S_un.S_addr=inet_addr(SERVER_IP); //服务器地址 addrServer.sin_port=htons(SERVER_PORP); //服务器端口号 addrServer.sin_family=AF_INET; //与服务器端建立连接，进行通信 int connReult=connect(sockClient,(SOCKADDR*)&amp;addrServer,sizeof(SOCKADDR)); if(connReult!=WSAEADDRNOTAVAIL) //访问成功 &#123; //成功建立连接后向服务器端发送数据，结果将显示在服务器端上 char sendInfo[100]; send(sockClient,"this is zhangsan!",strlen("this is zhangsan!")+1,0); //接收来自服务器端发送来的信息 char recvInfo[100]; recv(sockClient,recvInfo,100,0); printf("%s\n",recvInfo); while(1) &#123; scanf("%s",sendInfo); send(sockClient,sendInfo,strlen(sendInfo)+1,0); recv(sockClient,recvInfo,100,0); printf("%s",recvInfo); recv(sockClient,recvInfo,100,0); printf("%s",recvInfo); &#125; &#125; else &#123; int errCode=WSAGetLastError(); printf("the errcode is:%d\n",errCode); &#125; closesocket(sockClient); WSACleanup();&#125; 客户端和服务器应分别属于两个项目先运行服务器，后运行客户端]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>TCP</tag>
        <tag>套接字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言多线程学习(VC6++环境)]]></title>
    <url>%2F2017%2F09%2F04%2FC%E8%AF%AD%E8%A8%80%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1.简单的创建多线程实例1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;windows.h&gt;//子线程函数DWORD WINAPI ThreadFun(LPVOID pM)&#123; printf("子线程的线程ID号为：%d\n子线程输出 Hello World\n", GetCurrentThreadId()); return 0;&#125;//主函数，所谓主函数其实就是主线程执行的函数。int main()&#123; printf("最简单的创建多线程实例\n"); printf("http://zfblog.xyz"); HANDLE handle = CreateThread(NULL, 0, ThreadFun, NULL, 0, NULL); WaitForSingleObject(handle, INFINITE); return 0;&#125; 使用CreateThread函数创建线程1234567HANDLE WINAPI CreateThread( LPSECURITY_ATTRIBUTES lpThreadAttributes, DWORD dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId); 第一个参数表示线程内核对象的安全属性,一般传入NULL表示使用默认设置第二个参数表示线程栈空间大小,传入0表示使用默认大小(1MB)第三个参数表示新线程所执行的线程函数地址 多个线程可以使用同一个函数地址(线程函数入口)第四个参数是传给线程函数的参数第五个参数指定额外的标志来控制线程的创建 就是控制线程何时运行 为0:直接运行 为CREATE_SUSPENDED:调用ResumeThread()后运行第六个参数将返回线程的ID号,传入NULL表示不需要返回该线程ID号函数返回值:成功返回新线程的句柄,失败返回NULL2.关于CreateThread()该线程函数传递参数的问题1234567891011//创建线程时传递参数int *parameter;CreateThread(NULL, 0, ThreadFun, (void *)parameter, 0, NULL);//parameter是任意类型的地址//线程函数中调用参数DWORD WINAPI ThreadFun(LPVOID pM)&#123; //传入的地址指向一个int类型的数据 int p=*PM; return 0;&#125; WaitForSingleObject函数作用1234DWORD WINAPI WaitForSingleObject( HANDLE hHandle, DWORD dwMilliseconds); 第一个参数为要等待的内核对象第二个参数为最长等待的时间 为5000:等待5秒 为0:立即执行 为INFINITE:无限等待函数返回值:WAIT_OBJECT_0在指定的时间内对象被触发 WAIT_TIMEOUT超过最长等待时间对象仍未被触发 WAIT_FAILED传入参数有错误 函数作用首先要知道—-线程的句柄在线程运行时是未触发的，结束后触发在主函数中调用等待线程执行完毕，然后主函数结束不用此函数可能会导致线程没有执行完，主函数结束，程序结束]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows系统盘瘦身]]></title>
    <url>%2F2017%2F09%2F02%2Fwindows%E7%B3%BB%E7%BB%9F%E7%9B%98%E7%98%A6%E8%BA%AB%2F</url>
    <content type="text"><![CDATA[1.关闭系统休眠功能，删除Hiberfil.sys文件管理员运行cmd输入下面命令powercfg -h of2.设置虚拟内存控制面板—&gt;(系统和安全)—&gt;系统—&gt;高级系统设置—&gt;(高级)—&gt;设置—&gt;(高级)—&gt;更改把虚拟内存设置到其它盘3.删除临时文件以下三个目录里的文件是临时文件，可以删除C:\windows\tempC:\ProgramData\TEMPC:\Users\你的用户名\AppData\Local\Temp]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[powershell脚本遍历目录]]></title>
    <url>%2F2017%2F09%2F01%2Fpowershell%E8%84%9A%E6%9C%AC%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[遍历目录及子目录,显示目录大小12345678910111213141516function filesize ([string]$filepath) &#123; if ($filepath -eq $null) &#123; throw &quot;路径不能为空&quot; &#125; dir -Path $filepath | ForEach-Object -Process &#123; if ($_.psiscontainer -eq $true) &#123; $length = 0 dir -Path $_.fullname -Recurse | ForEach-Object &#123; $length += $_.Length &#125; $l = $length / 1KB $_.name + &quot;文件夹的大小为: &#123;0:n1&#125; KB&quot; -f $l &#125; &#125;&#125;filesize -filepath &quot;D:\&quot; 运行示例:12345678910111213141516171819202122PS F:\python&gt; function filesize ([string]$filepath) &#123;&gt;&gt; if ($filepath -eq $null) &#123;&gt;&gt; throw &quot;路径不能为空&quot;&gt;&gt; &#125;&gt;&gt; dir -Path $filepath | ForEach-Object -Process &#123;&gt;&gt; if ($_.psiscontainer -eq $true) &#123;&gt;&gt; $length = 0&gt;&gt; dir -Path $_.fullname -Recurse | ForEach-Object &#123;&gt;&gt; $length += $_.Length&gt;&gt; &#125;&gt;&gt; $l = $length / 1KB&gt;&gt; $_.name + &quot;文件夹的大小为: &#123;0:n1&#125; KB&quot; -f $l&gt;&gt; &#125;&gt;&gt; &#125;&gt;&gt; &#125;PS F:\python&gt; filesize -filepath &quot;f:\python&quot;ipluyou文件夹的大小为: 82,196.5 KBloginip_jlu文件夹的大小为: 16.8 KB嗅事百科文件夹的大小为: 4.3 KB小说文件夹的大小为: 31,043.6 KB笑料文件夹的大小为: 1,578,575.8 KBPS F:\python&gt;]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>powershell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[powershell卸载自带应用]]></title>
    <url>%2F2017%2F09%2F01%2Fpowershell%E5%8D%B8%E8%BD%BD%E8%87%AA%E5%B8%A6%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[卸载全部自带应用Get-AppxPackage -User $env:USERNAME | Remove-AppxPackage其他更多卸载OneNote:Get-AppxPackage OneNote | Remove-AppxPackage3D:Get-AppxPackage 3d | Remove-AppxPackageCamera相机:Get-AppxPackage camera | Remove-AppxPackage邮件和日历:Get-AppxPackage communi | Remove-AppxPackage新闻订阅:Get-AppxPackage bing | Remove-AppxPackageGroove音乐电影与电视:Get-AppxPackage zune | Remove-AppxPackage人脉:Get-AppxPackage people | Remove-AppxPackage手机伴侣Phone Companion:Get-AppxPackage phone | Remove-AppxPackage照片:Get-AppxPackage photo | Remove-AppxPackage纸牌游戏(还敢要钱的那货):Get-AppxPackage solit | Remove-AppxPackage录音机:Get-AppxPackage soundrec | Remove-AppxPackageXbox:Get-AppxPackage xbox | Remove-AppxPackage]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>powershell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己写一个Android照相机应用-2]]></title>
    <url>%2F2017%2F08%2F19%2F%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AAAndroid%E7%85%A7%E7%9B%B8%E6%9C%BA%E5%BA%94%E7%94%A8-2%2F</url>
    <content type="text"><![CDATA[自定义相机首先是要创建camera的生命周期123getCamera();//获取Camera对象setStartPreview(Camera camera,SurfaceHolder holder);//预览相机内容releaseCamera();//释放相机资源 activity生命周期与camera绑定12345678910111213protected void onResume() &#123; super.onResume(); if (mCamera == null) &#123; mCamera = getCamera(); if (mHolder != null) &#123; setStartPreview(mCamera,mHolder); &#125; &#125;&#125;protected void onPause() &#123; super.onPause(); releaseCamera();&#125; camera与surfaceview绑定12345678910111213141516//预览图像与camera绑定@Overridepublic void surfaceCreated(SurfaceHolder holder) &#123; setStartPreview(mCamera,mHolder);&#125;@Overridepublic void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; mCamera.stopPreview(); setStartPreview(mCamera,mHolder);&#125;@Overridepublic void surfaceDestroyed(SurfaceHolder holder) &#123; releaseCamera();&#125; 声明相机使用权限1&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;&lt;/uses-permission&gt; 实现照相，通过回调将照片数据保存到文件，并将文件路径传递到其它activity(ResultAty)12345678910111213141516171819202122232425262728293031323334private Camera.PictureCallback mPictureCallback = new Camera.PictureCallback() &#123; @Override public void onPictureTaken(byte[] data, Camera camera) &#123;//data中存储照片的全部信息 File tempFile = new File("/sdacrd/temp.png"); try &#123; FileOutputStream fos = new FileOutputStream(tempFile); fos.write(data); fos.close(); Intent intent = new Intent(CustomCamera.this,ResultAty.class); intent.putExtra("picPath",tempFile.getAbsolutePath()); startActivity(intent); CustomCamera.this.finish(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;;public void capture(View view)&#123; Camera.Parameters parameters = mCamera.getParameters(); parameters.setPictureFormat(ImageFormat.JPEG);//设置拍照格式jpg格式 parameters.setPictureSize(800,400);//设置照片大小 parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO);//设置自动对焦 mCamera.autoFocus(new Camera.AutoFocusCallback() &#123; //回调，对焦最清晰时拍照 @Override public void onAutoFocus(boolean success, Camera camera) &#123; if (success) &#123; mCamera.takePicture(null,null,mPictureCallback); &#125; &#125; &#125;);&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>相机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA套接字之TCP实现聊天室]]></title>
    <url>%2F2017%2F08%2F10%2FJAVA%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B9%8BTCP%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E5%AE%A4%2F</url>
    <content type="text"><![CDATA[java实现聊天室通过多线程实现随时加入，随时退出 客户端程序客户端有两个线程一个线程由主类SocketClient实现向服务器发送消息一个线程由内部类readLineThread实现监听服务器发来的消息并显示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import java.io.BufferedReader;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.Socket;public class SocketClient extends Socket&#123; private static final String SERVER_IP = "127.0.0.1"; private static final int SERVER_PORT = 2017; private Socket client; private PrintWriter out; private BufferedReader in; /** * 与服务器连接，并输入发送消息 */ public SocketClient() throws Exception&#123; super(SERVER_IP, SERVER_PORT); client = this; out = new PrintWriter(this.getOutputStream(), true); in = new BufferedReader(new InputStreamReader(this.getInputStream())); new readLineThread(); while(true)&#123; in = new BufferedReader(new InputStreamReader(System.in)); String input = in.readLine(); out.println(input); &#125; &#125; /** * 用于监听服务器端向客户端发送消息线程类 */ class readLineThread extends Thread&#123; private BufferedReader buff; public readLineThread()&#123; try &#123; buff = new BufferedReader(new InputStreamReader(client.getInputStream())); start(); &#125; catch (Exception e) &#123; &#125; &#125; @Override public void run() &#123; try &#123; while(true)&#123; String result = buff.readLine(); if("byeClient".equals(result))&#123;//客户端申请退出，服务端返回确认退出 break; &#125;else&#123;//输出服务端发送消息 System.out.println(result); &#125; &#125; in.close(); out.close(); client.close(); &#125; catch (Exception e) &#123; &#125; &#125; &#125; public static void main(String[] args) &#123; try &#123; new SocketClient();//启动客户端 &#125; catch (Exception e) &#123; &#125; &#125;&#125; 服务器程序服务器由三个类实现主类Server监听客户端请求，并启用线程处理请求内部类PrintOutThread监听输出消息请求，将消息发送到所有客户端内部类ServerThread提供与每一个用户的连接123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket;import java.util.ArrayList;import java.util.LinkedList;import java.util.List;public class Server extends ServerSocket &#123; private static final int SERVER_PORT = 2017; private static boolean isPrint = false;// 是否输出消息标志 private static List user_list = new ArrayList();// 登录用户集合 private static List&lt;ServerThread&gt; thread_list = new ArrayList&lt;ServerThread&gt;();// 服务器已启用线程集合 private static LinkedList message_list = new LinkedList();// 存放消息队列 /** * 创建服务端Socket,创建向客户端发送消息线程,监听客户端请求并处理 */ public Server() throws IOException &#123; super(SERVER_PORT);// 创建ServerSocket new PrintOutThread();// 创建向客户端发送消息线程 try &#123; while (true) &#123;// 监听客户端请求，启用一个线程处理 Socket socket = accept(); new ServerThread(socket); &#125; &#125; catch (Exception e) &#123; &#125; finally &#123; close(); &#125; &#125; /** * 监听是否有输出消息请求线程类,向客户端发送消息 */ class PrintOutThread extends Thread &#123; public PrintOutThread() &#123; start(); &#125; @Override public void run() &#123; while (true) &#123; //没有打印这句，if里面的语句不会执行，可能是多线程访问isPrint造成的 System.out.println("运行中。。。"+isPrint); if (isPrint) &#123;// 将缓存在队列中的消息按顺序发送到各客户端,并从队列中清除。 String message = (String) message_list.getFirst(); for (ServerThread thread : thread_list) &#123; thread.sendMessage(message); &#125; message_list.removeFirst(); isPrint = message_list.size() &gt; 0 ? true : false; &#125; &#125; &#125; &#125; /** * 服务器线程类 */ @SuppressWarnings("unchecked") class ServerThread extends Thread &#123; private Socket client; private PrintWriter out; private BufferedReader in; private String name; public ServerThread(Socket s) throws IOException &#123; client = s; out = new PrintWriter(client.getOutputStream(), true); in = new BufferedReader(new InputStreamReader(client.getInputStream())); //in.readLine(); out.println("成功连上聊天室,请输入你的名字："); start(); &#125; @Override public void run() &#123; try &#123; int flag = 0; String line = in.readLine(); while (true) &#123; // 查看在线用户列表 if ("showuser".equals(line)) &#123; out.println(this.listOnlineUsers()); &#125; if("bye".equals(line))&#123; out.println("bye"); break;&#125; // 第一次进入，保存名字 if (flag++ == 0) &#123; name = line; user_list.add(name); thread_list.add(this); out.println(name + "你好,可以开始聊天了..."); this.pushMessage("Client&lt;" + name + "&gt;进入聊天室..."); &#125; else &#123; this.pushMessage("Client&lt;" + name + "&gt; say : " + line); &#125; line = in.readLine(); &#125; out.println("byeClient"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123;// 用户退出聊天室 try &#123; client.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; thread_list.remove(this); user_list.remove(name); pushMessage("Client&lt;" + name + "&gt;退出了聊天室"); &#125; &#125; // 放入消息队列末尾，准备发送给客户端 private void pushMessage(String msg) &#123; message_list.addLast(msg); isPrint = true; &#125; // 向客户端发送一条消息 private void sendMessage(String msg) &#123; out.println(msg); &#125; // 统计在线用户列表 private String listOnlineUsers() &#123; String s = "--- 在线用户列表 ---\015\012"; for (int i = 0; i &lt; user_list.size(); i++) &#123; s += "[" + user_list.get(i) + "]\015\012"; &#125; s += "--------------------"; return s; &#125; &#125; public static void main(String[] args) throws IOException &#123; new Server();// 启动服务端 &#125;&#125; 这里好像出现了多线程问题123456789101112131415@Overridepublic void run() &#123; while (true) &#123; //没有打印下面这句，if里面的语句不会执行，可能是多线程访问isPrint造成的 System.out.println("运行中。。。"+isPrint); if (isPrint) &#123;// 将缓存在队列中的消息按顺序发送到各客户端，并从队列中清除。 String message = (String) message_list.getFirst(); for (ServerThread thread : thread_list) &#123; thread.sendMessage(message); &#125; message_list.removeFirst(); isPrint = message_list.size() &gt; 0 ? true : false; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>TCP</tag>
        <tag>聊天室</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA套接字之TCP简单实用]]></title>
    <url>%2F2017%2F08%2F09%2FJAVA%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B9%8BTCP%E7%AE%80%E5%8D%95%E5%AE%9E%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1,单客户端排队与服务器建立连接 客户端程序123456789101112131415161718192021222324252627import java.net.*;import java.io.*;public class Client&#123; static Socket server; public static void main(String[] args)throws Exception&#123; //客户端请求与本机在5678端口建立TCP连接 server=new Socket(InetAddress.getLocalHost(),5678); BufferedReader in= new BufferedReader(new InputStreamReader(server.getInputStream())); //获取Socket的输入流，用来接收从服务端发送过来的数据 PrintWriter out=new PrintWriter(server.getOutputStream()); //获取Socket的输出流，用来发送数据到服务端 BufferedReader wt=new BufferedReader(new InputStreamReader(System.in)); //从键盘输入的数据流 while(true)&#123; String str=wt.readLine();//读取键盘输入字符串 out.println(str);//发送数据到服务端 out.flush(); if(str.equals("end"))&#123; break; &#125; System.out.println(in.readLine());//打印服务器返回的字符串 &#125; server.close();//关闭连接 &#125;&#125; 服务器程序11234567891011121314151617181920212223import java.io.*;import java.net.*;public class Server &#123; public static void main(String[] args) throws IOException&#123; ServerSocket server=new ServerSocket(5678);//通信端口 while(true)&#123;//一个客户端断开连接后，等待与另一个客户端建立连接 Socket client=server.accept();//accept用于产生"阻塞"，直到接受到一个连接，并且返回一个客户端的Socket对象实例。 BufferedReader in= new BufferedReader(new InputStreamReader(client.getInputStream())); PrintWriter out=new PrintWriter(client.getOutputStream()); while(true)&#123;//直到客户端发送end退出循环 String str=in.readLine(); System.out.println(str); out.println("has receive...."); out.flush(); if(str.equals("end")) break; &#125; client.close();//关闭通信 &#125; &#125; &#125; 2,多个客户端同时与服务器建立连接客户端程序不变,服务器端阻塞等待客户端连接,并给每个链接分配一个线程 服务器程序212345678910111213141516171819202122232425262728293031323334353637import java.io.*;import java.net.*;public class Server extends Thread &#123;//继承Thread类 private Socket client; public Server(Socket c)&#123;//类初始化，接受参数为客户端的请求 this.client = c; &#125; public void run()&#123;//重写run函数 try&#123; BufferedReader in= new BufferedReader(new InputStreamReader(client.getInputStream())); PrintWriter out=new PrintWriter(client.getOutputStream()); while(true)&#123; String str=in.readLine(); System.out.println(str); out.println("has receive...."); out.flush(); if(str.equals("end")) break; &#125; client.close(); &#125;catch(IOException ex)&#123; &#125;finally&#123; &#125; &#125; public static void main(String[] args) throws IOException&#123; ServerSocket server=new ServerSocket(5678); while(true)&#123; Server mu=new Server(server.accept());//每当有客户端请求就新建一个Server类与之通信 mu.start();//启动进程 &#125; &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己写一个Android照相机应用-1]]></title>
    <url>%2F2017%2F08%2F09%2F%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AAAndroid%E7%85%A7%E7%9B%B8%E6%9C%BA%E5%BA%94%E7%94%A8-1%2F</url>
    <content type="text"><![CDATA[Android Camera相关知识调用系统相机12345678910111213Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);//使用action启动系统相机//startActivity(intent); //仅调用相机拍照，不返回数据//startActivityForResult(intent,REQ_1);//调用相机并通过onActivityResult函数data返回数据；Uri photoUri = Uri.fromFile(new File(mFilePath));//图片保存路径intent.putExtra(MediaStore.EXTRA_OUTPUT,photoUri);startActivityForResult(intent,REQ_2);//从文件中读取数据 路径获取12&lt;pre class=&quot;hljs undefined&quot;&gt;`mFilePath = Environment.getExternalStorageDirectory().getPath();mFilePath = mFilePath + &quot;/&quot; + &quot;tmp.png&quot;; 读取内存卡权限1&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&gt;&lt;/uses-permission&gt; onActivityResult函数12345678910111213141516171819202122232425protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if(resultCode == RESULT_OK)&#123; if (requestCode == REQ_1) &#123;//从data获取照片 Bundle bundle = data.getExtras(); Bitmap bitmap = (Bitmap)bundle.get("data"); mImageView.setImageBitmap(bitmap); &#125; else if (requestCode == REQ_2) &#123;//从文件获取照片 FileInputStream fis = null; try &#123; fis = new FileInputStream(mFilePath); Bitmap bitmap = BitmapFactory.decodeStream(fis); mImageView.setImageBitmap(bitmap); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; 注册action，实现照相功能1234&lt;intent-filter&gt; &lt;action android:name=&quot;android.media.action.IMAGE_CAPTURE&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;&lt;/intent-filter&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>相机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab函数freqs和freqz]]></title>
    <url>%2F2017%2F08%2F09%2FMatlab%E5%87%BD%E6%95%B0freqs%E5%92%8Cfreqz%2F</url>
    <content type="text"><![CDATA[1,freqs模拟滤波器的频率响应语法：1234h = freqs(b,a,w)[h,w] = freqs(b,a)[h,w] = freqs(b,a,f)freqs(b,a) 描述：freqs 返回一个模拟滤波器的H(jw)的复频域响应（拉普拉斯格式）h = freqs(b, a, w) 根据系数向量计算返回模拟滤波器的复频域响应freqs 计算在复平面虚轴上的频率响应h，角频率w确定了输入的实向量，因此必须包含至少一个频率点。[h, w] = freqs(b, a) 自动挑选200个频率点来计算频率响应h[h, w] = freqs(b, a, f) 挑选f个频率点来计算频率响应h例子：找到并画出下面传递函数的频率响应 Matlab代码：1234a = [1 0.4 1];b = [0.2 0.3 1];w = logspace(-1, 1);freqs(b, a, w); logspace 功能：生成从10的a次方到10的b次方之间按对数等分的n个元素的行向量n如果省略，则默认值为50。12345h=freqs(b,a,w);mag = abs(h);phase = angle(h);subplot(2,1,1), loglog(w,mag);subplot(2,1,2), semilogx(w,phase);f = w/(2*pi);mag = 20*log10(mag);phase = phase*180/pi; 2,freqzMATLAB提供了专门用于求离散系统频响特性的函数freqz()调用freqz()的格式有以下两种：(1):[H,w]=freqz(B,A,N) B和A分别为离散系统的系统函数分子、分母多项式的系数向量，N为正整数，返回量H则包含了离散系统频响 在 0——pi范围内N个频率等分点的值，向量w则包含 范围内N个频率等分点。调用中若N默认，默认值为512。(2):[H,w]=freqz(B,A,N,’whole’)该调用格式将计算离散系统在0—pi范内的N个频率等分店的频率响应的值。因此，可以先调用freqz()函数计算系统的频率响应，然后利用abs()和angle()函数及plot()函数，即可绘制出系统在 或 范围内的频响曲线。例：绘制如下系统的频响曲线H(z)=(z-0.5)/zMATLAB命令如下：123B=[1 -0.5];A =[1 0];[H,w]=freqz(B,A,400,'whole'); H是频率响应的幅度，w是0—pi内的400个点123456789Hf=abs(H);Hx=angle(H);clffigure(1)plot(w,Hf)title('离散系统幅频特性曲线')figure(2)plot(w,Hx)title('离散系统相频特性曲线') 幅频特性.PNG 相频特性.PNG这样画出来的是线性的，要想获得db格式的幅度，需要转换 20*log10（Hf）之后再画就是db格式的也可以直接用freqz(b,a,w)这样就会画出幅频响应和相频响应，幅频响应直接是db格式的幅度。]]></content>
      <categories>
        <category>Matlab</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
        <tag>freqs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyQt5]]></title>
    <url>%2F2017%2F08%2F09%2FPyQt5%2F</url>
    <content type="text"><![CDATA[安装1pip install python-qt5 把ui转py1python -m PyQt5.uic.pyuic &lt;arguments&gt; lineEdit输入隐藏，密码1lineEdit.setEchoMode(QtWidgets.QLineEdit.Password) py转exe12pip install pyinstallerpyinstaller demo.py 参数 含义 -F 指定打包后只生成一个exe格式的文件 -D –onedir创建一个目录,包含exe文件,但会依赖很多文件（默认选项） -c –console,–nowindowed使用控制台,无界面(默认) -w –windowed,–noconsole使用窗口,无控制台 -p 添加搜索路径,让其找到对应的库。 -i 改变生成程序的icon图标]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>PyQt5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搬瓦工VPS搭建Web服务器]]></title>
    <url>%2F2017%2F08%2F04%2F%E6%90%AC%E7%93%A6%E5%B7%A5VPS%E6%90%AD%E5%BB%BAWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[在centos上安装apache+php+mysql的过程搬瓦工VPS购买地址 安装apache安装yum install httpd 启动service httpd start暂停service httpd stop重启service httpd restart 检查开机启动情况chkconfig --list httpd默认情况下是全部关闭的，尽量设置开机启动，以防主机意外关机 设置开机启动命令chkconfig httpd on再次检查启动情况，看到2，3，4，5为启动关闭开机启动命令chkconfig httpd off 到此Apache安装完成，在自己浏览器中输入主机IP和端口号能正常打开 安装php命令为123yum install phpyum install php-mysql php-gd php-imap php-ldap php-odbc php-pear php-xml php-xmlrpcyum install php-mysql 以上命令为安装php及其支持的组件 安装mysql安装首先查看主机是否已经安装rpm -qa|grep mysql 注意：可能检查中安装有php-mysql XXXXX 和 mysql-libXXXX,这是刚刚第二步安装的php的组件,不必理会 已经安装的话就执行删除命令rmp -e mysql 然后继续安装使用命令yum list | grep mysql来查看yum上提供的mysql数据库可下载的版本 安装命令yum install -y mysql-server mysql mysql-devel等待一段时间安装成功 配置接下来是对mysql的配置(注意:命令中是”mysqld”,不是mysql) 初始化:service mysqld start重启:service mysqld restart配置开机自动启动:chkconfig mysqld on 为mysql的root账户设置密码:mysqladmin -u root password &#39;*********&#39;登录命令mysql -u root -p]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>搬瓦工</tag>
        <tag>apache</tag>
        <tag>php</tag>
        <tag>mysql</tag>
        <tag>web</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python2与Python3共存]]></title>
    <url>%2F2017%2F08%2F03%2FPython2%E4%B8%8EPython3%E5%85%B1%E5%AD%98%2F</url>
    <content type="text"><![CDATA[安装两个版本的Pythonpython2下载地址:https://www.python.org/ftp/python/2.7.13/python-2.7.13.msipython3下载地址:https://www.python.org/ftp/python/3.6.2/python-3.6.2.exe进行安装(安装顺序随便) 尽量安装到同一目录下的两个文件夹例如:python2安装在”D:\program\python27\”下python3安装在”D:\program\python36\”下 添加环境变量Path中要有一下四个路径1234D:\program\python\Python36\Scripts\D:\program\python\Python36\D:\program\python\python27\ScriptsD:\program\python\python27\ 更改python.exe名字找到找到两个python的安装目录D:\program\python\Python36\python.exe更改为D:\program\python\Python36\python3.exeD:\program\python\Python27\python.exe更改为D:\program\python\Python36\python2.exe 此时两个版本的python已经共同存在但还要对pip进行修改 更改pip名称重装python2和python3的pip12python2 -m pip install --upgrade pip --force-reinstallpython3 -m pip install --upgrade pip --force-reinstall 重装成功后进行如下测试可见python2和python3已经共存pip的问题也解决了但直接调用pip是还能执行并且是后安装的pip的版本python命令已经不存在直接运行py结尾的文件时会出现问题python自带的编辑器出现了两个]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搬瓦工安装ss并加速]]></title>
    <url>%2F2017%2F08%2F03%2F%E6%90%AC%E7%93%A6%E5%B7%A5%E5%AE%89%E8%A3%85ss%E5%B9%B6%E5%8A%A0%E9%80%9F%2F</url>
    <content type="text"><![CDATA[搬瓦工（BandwagonHost）是美国IT7公司旗下的一家提供便宜年付OVZ架构的VPS主机方案的服务商。价格便宜、且依托的商家比较靠谱，具有较高的性价比。拿来搭个FQ是非常合适的，做个小站也是可以的。 1.购买地址 搬瓦工所有配置及购买地址:https://bandwagonhost.com/aff.php?aff=17697以前有小内存的VPS年费三刀，很便宜，但现在没有了，缺货，连521M的有时候也会缺货，看来挺火的。 2.安装Shadowsocks2.1搬瓦工后台一键安装(不推荐)登录账号-&gt;Client Area-&gt;Services-&gt;My Services-&gt;KiwiVM Control Panel来到管理面板，点击 Shadowsocks Server 就可以一键安装 Shadowsocks测试过它自带的一键安装，速度太慢，yotube视频看不了，有点慢。 2.2使用shell脚本安装(推荐)2.2.1安装 shadowsoksRShadowsocks的一个分支，比较不错。但是默认是 aes-256-cfb 加密，如果需要 chacha20 加密，需要手动切换。123wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.shchmod +x shadowsocksR.sh./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log 安装成功需要等几分钟这个速度可以看yotube无压力 卸载方法：使用 root 用户登录，运行以下命令：1./shadowsocksR.sh uninstall 安装完成后即已后台启动 ShadowsocksR,运行：1/etc/init.d/shadowsocks status 可以查看 ShadowsocksR 进程是否已经启动。本脚本安装完成后，已将 ShadowsocksR 自动加入开机自启动。 其它命令：启动：/etc/init.d/shadowsocks start停止：/etc/init.d/shadowsocks stop重启：/etc/init.d/shadowsocks restart状态：/etc/init.d/shadowsocks status 配置文件路径：/etc/shadowsocks.json日志文件路径：/var/log/shadowsocks.log代码安装目录：/usr/local/shadowsocks 2.2.1安装 shadowsocks-go版本据说有buff，比python版Shadowsocks要快：123wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-go.shchmod +x shadowsocks-go.sh./shadowsocks-go.sh 2&amp;gt;&amp;amp;1 | tee shadowsocks-go.log 2.2.3其他版本Shadowsocks一键安装：来自 teddysun：https://github.com/teddysun/shadowsocks_install 3.遇到的一些问题3.1搬瓦工默认系统Centos没有wget命令需要安装安装命令:1yum -y install wget 3.2关于配置多用户1vi /etc/shadowsocks.json 只需要在port_password项下添加”端口号”:”密码”1234567891011121314151617181920&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;server_ipv6&quot;:&quot;[::]&quot;, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;port_password&quot;:&#123; &quot;28998&quot;: &quot;123456&quot;, &quot;28989&quot;: &quot;123456&quot; &#125;, &quot;timeout&quot;:120, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;protocol&quot;:&quot;origin&quot;, &quot;protocol_param&quot;:&quot;&quot;, &quot;obfs&quot;:&quot;plain&quot;, &quot;obfs_param&quot;:&quot;&quot;, &quot;redirect&quot;:&quot;&quot;, &quot;dns_ipv6&quot;:false, &quot;fast_open&quot;:false, &quot;workers&quot;:1&#125; 参见:https://blog.kuoruan.com/48.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>搬瓦工</tag>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA实现MD5加密]]></title>
    <url>%2F2017%2F07%2F02%2FJAVA%E5%AE%9E%E7%8E%B0MD5%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[java实现MD5加密的两种方法1,调用MessageDigest实现12345678910111213141516171819202122232425262728293031323334353637383940import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public class CreatMD5 &#123; public String getMd5(String plainText)&#123; try &#123; MessageDigest md = MessageDigest.getInstance("MD5"); md.update(plainText.getBytes()); byte b[] = md.digest(); int i; StringBuffer buf = new StringBuffer(""); for (int offset = 0; offset &lt; b.length; offset++) &#123; i = b[offset]; if (i &lt; 0) i += 256; if (i &lt; 16) buf.append("0"); buf.append(Integer.toHexString(i)); &#125; //32位加密 return buf.toString(); // 16位的加密 //return buf.toString().substring(8, 24); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); return null; &#125; &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub CreatMD5 md=new CreatMD5(); System.out.println(md.getMd5("hello")); &#125;&#125; 2,自己编写函数实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273public class CreateMD5i &#123; static final String hexs[]=&#123;"0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F"&#125;; //标准的幻数 private static final long A=0x67452301L; private static final long B=0xefcdab89L; private static final long C=0x98badcfeL; private static final long D=0x10325476L; //下面这些S11-S44实际上是一个4*4的矩阵，在四轮循环运算中用到 static final int S11 = 7; static final int S12 = 12; static final int S13 = 17; static final int S14 = 22; static final int S21 = 5; static final int S22 = 9; static final int S23 = 14; static final int S24 = 20; static final int S31 = 4; static final int S32 = 11; static final int S33 = 16; static final int S34 = 23; static final int S41 = 6; static final int S42 = 10; static final int S43 = 15; static final int S44 = 21; //java不支持无符号的基本数据（unsigned） private long [] result=&#123;A,B,C,D&#125;;//存储hash结果，共4×32=128位，初始化值为（幻数的级联） public static void main(String []args)&#123; CreateMD5i md=new CreateMD5i(); System.out.println("md5(hello)="+md.digest("hello")); &#125; public String digest(String inputStr)&#123; byte [] inputBytes=inputStr.getBytes(); int byteLen=inputBytes.length;//长度（字节） int groupCount=0;//完整分组的个数 groupCount=byteLen/64;//每组512位（64字节） long []groups=null;//每个小组(64字节)再细分后的16个小组(4字节) //处理每一个完整 分组 for(int step=0;step&lt;groupCount;step++)&#123; groups=divGroup(inputBytes,step*64); trans(groups);//处理分组，核心算法 &#125; //处理完整分组后的尾巴 int rest=byteLen%64;//512位分组后的余数 byte [] tempBytes=new byte[64]; if(rest&lt;=56)&#123; for(int i=0;i&lt;rest;i++) tempBytes[i]=inputBytes[byteLen-rest+i]; if(rest&lt;56)&#123; tempBytes[rest]=(byte)(1&lt;&lt;7); for(int i=1;i&lt;56-rest;i++) tempBytes[rest+i]=0; &#125; long len=(long)(byteLen&lt;&lt;3); for(int i=0;i&lt;8;i++)&#123; tempBytes[56+i]=(byte)(len&amp;0xFFL); len=len&gt;&gt;8; &#125; groups=divGroup(tempBytes,0); trans(groups);//处理分组 &#125;else&#123; for(int i=0;i&lt;rest;i++) tempBytes[i]=inputBytes[byteLen-rest+i]; tempBytes[rest]=(byte)(1&lt;&lt;7); for(int i=rest+1;i&lt;64;i++) tempBytes[i]=0; groups=divGroup(tempBytes,0); trans(groups);//处理分组 for(int i=0;i&lt;56;i++) tempBytes[i]=0; long len=(long)(byteLen&lt;&lt;3); for(int i=0;i&lt;8;i++)&#123; tempBytes[56+i]=(byte)(len&amp;0xFFL); len=len&gt;&gt;8; &#125; groups=divGroup(tempBytes,0); trans(groups);//处理分组 &#125; //将Hash值转换成十六进制的字符串 String resStr=""; long temp=0; for(int i=0;i&lt;4;i++)&#123; for(int j=0;j&lt;4;j++)&#123; temp=result[i]&amp;0x0FL; String a=hexs[(int)(temp)]; result[i]=result[i]&gt;&gt;4; temp=result[i]&amp;0x0FL; resStr+=hexs[(int)(temp)]+a; result[i]=result[i]&gt;&gt;4; &#125; &#125; return resStr; &#125; /** * 从inputBytes的index开始取512位，作为新的分组 * 将每一个512位的分组再细分成16个小组，每个小组64位（8个字节） * @param inputBytes * @param index * @return */ private static long[] divGroup(byte[] inputBytes,int index)&#123; long [] temp=new long[16]; for(int i=0;i&lt;16;i++)&#123; temp[i]=b2iu(inputBytes[4*i+index])| (b2iu(inputBytes[4*i+1+index]))&lt;&lt;8| (b2iu(inputBytes[4*i+2+index]))&lt;&lt;16| (b2iu(inputBytes[4*i+3+index]))&lt;&lt;24; &#125; return temp; &#125; /** * 这时不存在符号位（符号位存储不再是代表正负），所以需要处理一下 * @param b * @return */ public static long b2iu(byte b)&#123; return b &lt; 0 ? b &amp; 0x7F + 128 : b; &#125; /** * 主要的操作，四轮循环 * @param groups[]--每一个分组512位（64字节） */ private void trans(long[] groups) &#123; long a = result[0], b = result[1], c = result[2], d = result[3]; /*第一轮*/ a = FF(a, b, c, d, groups[0], S11, 0xd76aa478L); /* 1 */ d = FF(d, a, b, c, groups[1], S12, 0xe8c7b756L); /* 2 */ c = FF(c, d, a, b, groups[2], S13, 0x242070dbL); /* 3 */ b = FF(b, c, d, a, groups[3], S14, 0xc1bdceeeL); /* 4 */ a = FF(a, b, c, d, groups[4], S11, 0xf57c0fafL); /* 5 */ d = FF(d, a, b, c, groups[5], S12, 0x4787c62aL); /* 6 */ c = FF(c, d, a, b, groups[6], S13, 0xa8304613L); /* 7 */ b = FF(b, c, d, a, groups[7], S14, 0xfd469501L); /* 8 */ a = FF(a, b, c, d, groups[8], S11, 0x698098d8L); /* 9 */ d = FF(d, a, b, c, groups[9], S12, 0x8b44f7afL); /* 10 */ c = FF(c, d, a, b, groups[10], S13, 0xffff5bb1L); /* 11 */ b = FF(b, c, d, a, groups[11], S14, 0x895cd7beL); /* 12 */ a = FF(a, b, c, d, groups[12], S11, 0x6b901122L); /* 13 */ d = FF(d, a, b, c, groups[13], S12, 0xfd987193L); /* 14 */ c = FF(c, d, a, b, groups[14], S13, 0xa679438eL); /* 15 */ b = FF(b, c, d, a, groups[15], S14, 0x49b40821L); /* 16 */ /*第二轮*/ a = GG(a, b, c, d, groups[1], S21, 0xf61e2562L); /* 17 */ d = GG(d, a, b, c, groups[6], S22, 0xc040b340L); /* 18 */ c = GG(c, d, a, b, groups[11], S23, 0x265e5a51L); /* 19 */ b = GG(b, c, d, a, groups[0], S24, 0xe9b6c7aaL); /* 20 */ a = GG(a, b, c, d, groups[5], S21, 0xd62f105dL); /* 21 */ d = GG(d, a, b, c, groups[10], S22, 0x2441453L); /* 22 */ c = GG(c, d, a, b, groups[15], S23, 0xd8a1e681L); /* 23 */ b = GG(b, c, d, a, groups[4], S24, 0xe7d3fbc8L); /* 24 */ a = GG(a, b, c, d, groups[9], S21, 0x21e1cde6L); /* 25 */ d = GG(d, a, b, c, groups[14], S22, 0xc33707d6L); /* 26 */ c = GG(c, d, a, b, groups[3], S23, 0xf4d50d87L); /* 27 */ b = GG(b, c, d, a, groups[8], S24, 0x455a14edL); /* 28 */ a = GG(a, b, c, d, groups[13], S21, 0xa9e3e905L); /* 29 */ d = GG(d, a, b, c, groups[2], S22, 0xfcefa3f8L); /* 30 */ c = GG(c, d, a, b, groups[7], S23, 0x676f02d9L); /* 31 */ b = GG(b, c, d, a, groups[12], S24, 0x8d2a4c8aL); /* 32 */ /*第三轮*/ a = HH(a, b, c, d, groups[5], S31, 0xfffa3942L); /* 33 */ d = HH(d, a, b, c, groups[8], S32, 0x8771f681L); /* 34 */ c = HH(c, d, a, b, groups[11], S33, 0x6d9d6122L); /* 35 */ b = HH(b, c, d, a, groups[14], S34, 0xfde5380cL); /* 36 */ a = HH(a, b, c, d, groups[1], S31, 0xa4beea44L); /* 37 */ d = HH(d, a, b, c, groups[4], S32, 0x4bdecfa9L); /* 38 */ c = HH(c, d, a, b, groups[7], S33, 0xf6bb4b60L); /* 39 */ b = HH(b, c, d, a, groups[10], S34, 0xbebfbc70L); /* 40 */ a = HH(a, b, c, d, groups[13], S31, 0x289b7ec6L); /* 41 */ d = HH(d, a, b, c, groups[0], S32, 0xeaa127faL); /* 42 */ c = HH(c, d, a, b, groups[3], S33, 0xd4ef3085L); /* 43 */ b = HH(b, c, d, a, groups[6], S34, 0x4881d05L); /* 44 */ a = HH(a, b, c, d, groups[9], S31, 0xd9d4d039L); /* 45 */ d = HH(d, a, b, c, groups[12], S32, 0xe6db99e5L); /* 46 */ c = HH(c, d, a, b, groups[15], S33, 0x1fa27cf8L); /* 47 */ b = HH(b, c, d, a, groups[2], S34, 0xc4ac5665L); /* 48 */ /*第四轮*/ a = II(a, b, c, d, groups[0], S41, 0xf4292244L); /* 49 */ d = II(d, a, b, c, groups[7], S42, 0x432aff97L); /* 50 */ c = II(c, d, a, b, groups[14], S43, 0xab9423a7L); /* 51 */ b = II(b, c, d, a, groups[5], S44, 0xfc93a039L); /* 52 */ a = II(a, b, c, d, groups[12], S41, 0x655b59c3L); /* 53 */ d = II(d, a, b, c, groups[3], S42, 0x8f0ccc92L); /* 54 */ c = II(c, d, a, b, groups[10], S43, 0xffeff47dL); /* 55 */ b = II(b, c, d, a, groups[1], S44, 0x85845dd1L); /* 56 */ a = II(a, b, c, d, groups[8], S41, 0x6fa87e4fL); /* 57 */ d = II(d, a, b, c, groups[15], S42, 0xfe2ce6e0L); /* 58 */ c = II(c, d, a, b, groups[6], S43, 0xa3014314L); /* 59 */ b = II(b, c, d, a, groups[13], S44, 0x4e0811a1L); /* 60 */ a = II(a, b, c, d, groups[4], S41, 0xf7537e82L); /* 61 */ d = II(d, a, b, c, groups[11], S42, 0xbd3af235L); /* 62 */ c = II(c, d, a, b, groups[2], S43, 0x2ad7d2bbL); /* 63 */ b = II(b, c, d, a, groups[9], S44, 0xeb86d391L); /* 64 */ /*加入到之前计算的结果当中*/ result[0] += a; result[1] += b; result[2] += c; result[3] += d; result[0]=result[0]&amp;0xFFFFFFFFL; result[1]=result[1]&amp;0xFFFFFFFFL; result[2]=result[2]&amp;0xFFFFFFFFL; result[3]=result[3]&amp;0xFFFFFFFFL; &#125; /** * 下面是处理要用到的线性函数 */ private static long F(long x, long y, long z) &#123; return (x &amp; y) | ((~x) &amp; z); &#125; private static long G(long x, long y, long z) &#123; return (x &amp; z) | (y &amp; (~z)); &#125; private static long H(long x, long y, long z) &#123; return x ^ y ^ z; &#125; private static long I(long x, long y, long z) &#123; return y ^ (x | (~z)); &#125; private static long FF(long a, long b, long c, long d, long x, long s, long ac) &#123; a += (F(b, c, d)&amp;0xFFFFFFFFL) + x + ac; a = ((a&amp;0xFFFFFFFFL)&lt;&lt; s) | ((a&amp;0xFFFFFFFFL) &gt;&gt;&gt; (32 - s)); a += b; return (a&amp;0xFFFFFFFFL); &#125; private static long GG(long a, long b, long c, long d, long x, long s, long ac) &#123; a += (G(b, c, d)&amp;0xFFFFFFFFL) + x + ac; a = ((a&amp;0xFFFFFFFFL) &lt;&lt; s) | ((a&amp;0xFFFFFFFFL) &gt;&gt;&gt; (32 - s)); a += b; return (a&amp;0xFFFFFFFFL); &#125; private static long HH(long a, long b, long c, long d, long x, long s, long ac) &#123; a += (H(b, c, d)&amp;0xFFFFFFFFL) + x + ac; a = ((a&amp;0xFFFFFFFFL) &lt;&lt; s) | ((a&amp;0xFFFFFFFFL) &gt;&gt;&gt; (32 - s)); a += b; return (a&amp;0xFFFFFFFFL); &#125; private static long II(long a, long b, long c, long d, long x, long s, long ac) &#123; a += (I(b, c, d)&amp;0xFFFFFFFFL) + x + ac; a = ((a&amp;0xFFFFFFFFL) &lt;&lt; s) | ((a&amp;0xFFFFFFFFL) &gt;&gt;&gt; (32 - s)); a += b; return (a&amp;0xFFFFFFFFL); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MD5</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谷歌浏览器运行安卓APK]]></title>
    <url>%2F2017%2F06%2F25%2F%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%90%E8%A1%8C%E5%AE%89%E5%8D%93APK%2F</url>
    <content type="text"><![CDATA[使用谷歌浏览器的插件ARChon实现安卓APK在电脑上运行一些简单的应用可以实现，游戏等可能实现不了用谷歌插件在电脑上运行安卓APK 1，直接谷歌应用商店下载出现错误程序包无效：“CRX_SIGNATURE_VERIFICATION_FAILED”。 2，直接下载crx包参考百度经验3，出现错误：Cannot load extension with file or directory name _metadata. Filenames starting with “_” are reserved for use by the system.更改解压后文件夹_metadata为metadata4，出现错误：’import’ extension is not installed.打开文件manifest.json去掉import一句1&quot;import&quot;:[&#123;&quot;id&quot;:&quot;mfaihdlpglflfgpfjcifdjdjcckigekc&quot;&#125;], 继续谷歌去掉这句话不对看这篇CSDN文章说要下载插件ARChon (以下废话，直接看5）4.1，安装成功，但启用后一直白屏怀疑是不是去掉import一句出问题了4.2，网上看到开启Native Client谷歌浏览器地址栏输入chrome://flags/开启Native Client无用4.3，发现另一个谷歌商店的应用twerk这个应用是把 APK 文件转换成 Chrome App用的5ARChon是谷歌插件要在扩展程序，打钩开发者模式，点击加载已解压扩展程序，选择解压文件夹加载ARChon时有警告，可忽略先加载ARC Welder出现4的错误后再加载ARChon，然后ARC Welder就好了，不好的话重新加载就好了安装好了就是APK运行不了 4.3安装的twerk可以把 APK 文件转换一个文件夹然后ARC Welder运行 谷歌浏览器如何运行APK博客CSDN可以试一试 又遇到的问题Chrome加载Android应用，提示“There is no “message” element for key extName”错误，如： 解决方法：找到该Crx文件夹下的“_locales\en”目录下的“messages.json”文件，在“extName”节点下，添加“message”字段标签，值对应应用的包名：WebGL 不受支持知乎有教程浏览器快捷方式属性增加—ignore-gpu-blacklist开启硬件加速试了一下掌阅试了一下简书可以运行]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>安卓模拟器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[批处理for循环使用]]></title>
    <url>%2F2017%2F04%2F22%2F%E6%89%B9%E5%A4%84%E7%90%86for%E5%BE%AA%E7%8E%AF%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[windows批处理FOR循环的使用在cmd中输入使用时应写为1FOR %variable IN (set) DO command [command-parameters] command [command-parameters]中用到变量也要写为%variable写进.bat或者.cmd文件时应写为1FOR %%variable IN (set) DO command [command-parameters] command [command-parameters]中用到变量也要写为%%variableWindows自带的help解释:123456FOR %variable IN (set) DO command [command-parameters] %variable 指定一个单一字母可替换的参数。 (set) 指定一个或一组文件。可以使用通配符。 command 指定对每个文件执行的命令。 command-parameters 为特定命令指定参数或命令行开关。 在批处理程序中使用 FOR 命令时，指定变量请使用 %%variable而不要用 %variable。变量名称是区分大小写的，所以 %i 不同于 %I.]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>批处理</tag>
      </tags>
  </entry>
</search>
